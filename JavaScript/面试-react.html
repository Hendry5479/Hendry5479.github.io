<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>英俊的大亨亨</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="heng.png">
    <meta name="description" content="记录下有趣岁月的点点滴滴">
    
    <link rel="preload" href="/assets/css/0.styles.e4d8b86b.css" as="style"><link rel="preload" href="/assets/js/app.b51e4ccd.js" as="script"><link rel="preload" href="/assets/js/2.7229199a.js" as="script"><link rel="preload" href="/assets/js/19.3d59a8e1.js" as="script"><link rel="prefetch" href="/assets/js/10.00f8a9d8.js"><link rel="prefetch" href="/assets/js/100.78dfd44a.js"><link rel="prefetch" href="/assets/js/101.cdae98a0.js"><link rel="prefetch" href="/assets/js/102.6a3dd9e0.js"><link rel="prefetch" href="/assets/js/103.cfed07a2.js"><link rel="prefetch" href="/assets/js/104.a16a4843.js"><link rel="prefetch" href="/assets/js/105.9cd1add0.js"><link rel="prefetch" href="/assets/js/106.546c1ad8.js"><link rel="prefetch" href="/assets/js/107.04b38bf9.js"><link rel="prefetch" href="/assets/js/108.31a22b61.js"><link rel="prefetch" href="/assets/js/109.1f2a1840.js"><link rel="prefetch" href="/assets/js/11.e2689dc6.js"><link rel="prefetch" href="/assets/js/110.9dc2f13b.js"><link rel="prefetch" href="/assets/js/111.35cf70f8.js"><link rel="prefetch" href="/assets/js/112.39a6579b.js"><link rel="prefetch" href="/assets/js/113.cbfc279d.js"><link rel="prefetch" href="/assets/js/114.878470a2.js"><link rel="prefetch" href="/assets/js/115.86dc4d8e.js"><link rel="prefetch" href="/assets/js/116.d2e05b2c.js"><link rel="prefetch" href="/assets/js/117.7525671d.js"><link rel="prefetch" href="/assets/js/118.a5c04c6d.js"><link rel="prefetch" href="/assets/js/119.613a81e1.js"><link rel="prefetch" href="/assets/js/12.0b7aaea4.js"><link rel="prefetch" href="/assets/js/120.ec6d3159.js"><link rel="prefetch" href="/assets/js/121.6705f783.js"><link rel="prefetch" href="/assets/js/122.7b3fe034.js"><link rel="prefetch" href="/assets/js/123.9336f454.js"><link rel="prefetch" href="/assets/js/124.dca9fc87.js"><link rel="prefetch" href="/assets/js/125.338aa4d8.js"><link rel="prefetch" href="/assets/js/126.a731a9eb.js"><link rel="prefetch" href="/assets/js/127.da74dd90.js"><link rel="prefetch" href="/assets/js/128.3d5e86f2.js"><link rel="prefetch" href="/assets/js/129.ee43b65c.js"><link rel="prefetch" href="/assets/js/13.31064a46.js"><link rel="prefetch" href="/assets/js/130.8a273d75.js"><link rel="prefetch" href="/assets/js/131.a89df4ac.js"><link rel="prefetch" href="/assets/js/132.0daac28c.js"><link rel="prefetch" href="/assets/js/133.b1f23c92.js"><link rel="prefetch" href="/assets/js/134.78621a9c.js"><link rel="prefetch" href="/assets/js/135.f0884a8b.js"><link rel="prefetch" href="/assets/js/136.45114430.js"><link rel="prefetch" href="/assets/js/137.eb295fce.js"><link rel="prefetch" href="/assets/js/138.cc7dc8d3.js"><link rel="prefetch" href="/assets/js/139.c9b1aad6.js"><link rel="prefetch" href="/assets/js/14.0be4ee49.js"><link rel="prefetch" href="/assets/js/15.685fab30.js"><link rel="prefetch" href="/assets/js/16.97f8b16a.js"><link rel="prefetch" href="/assets/js/17.9c7bebeb.js"><link rel="prefetch" href="/assets/js/18.965d9e47.js"><link rel="prefetch" href="/assets/js/20.1573d510.js"><link rel="prefetch" href="/assets/js/21.f46234dd.js"><link rel="prefetch" href="/assets/js/22.6c16fd38.js"><link rel="prefetch" href="/assets/js/23.50a2a38a.js"><link rel="prefetch" href="/assets/js/24.8aff8273.js"><link rel="prefetch" href="/assets/js/25.35a7c496.js"><link rel="prefetch" href="/assets/js/26.af233874.js"><link rel="prefetch" href="/assets/js/27.a3a96a5a.js"><link rel="prefetch" href="/assets/js/28.a1d49602.js"><link rel="prefetch" href="/assets/js/29.174b7d7d.js"><link rel="prefetch" href="/assets/js/3.6038f64c.js"><link rel="prefetch" href="/assets/js/30.a4115d32.js"><link rel="prefetch" href="/assets/js/31.1522875a.js"><link rel="prefetch" href="/assets/js/32.35da527d.js"><link rel="prefetch" href="/assets/js/33.814d63e8.js"><link rel="prefetch" href="/assets/js/34.615b49c1.js"><link rel="prefetch" href="/assets/js/35.856ab789.js"><link rel="prefetch" href="/assets/js/36.2987bc62.js"><link rel="prefetch" href="/assets/js/37.084d12aa.js"><link rel="prefetch" href="/assets/js/38.088f3091.js"><link rel="prefetch" href="/assets/js/39.4ea066d5.js"><link rel="prefetch" href="/assets/js/4.c610d016.js"><link rel="prefetch" href="/assets/js/40.97850ba9.js"><link rel="prefetch" href="/assets/js/41.8b8ae086.js"><link rel="prefetch" href="/assets/js/42.8ae2cac3.js"><link rel="prefetch" href="/assets/js/43.f8a28187.js"><link rel="prefetch" href="/assets/js/44.5160f68a.js"><link rel="prefetch" href="/assets/js/45.6d4b7130.js"><link rel="prefetch" href="/assets/js/46.44693348.js"><link rel="prefetch" href="/assets/js/47.eb0ac18a.js"><link rel="prefetch" href="/assets/js/48.ce1c6335.js"><link rel="prefetch" href="/assets/js/49.7ec1b16a.js"><link rel="prefetch" href="/assets/js/5.216dfe20.js"><link rel="prefetch" href="/assets/js/50.1f503aa4.js"><link rel="prefetch" href="/assets/js/51.47971163.js"><link rel="prefetch" href="/assets/js/52.e5f681d7.js"><link rel="prefetch" href="/assets/js/53.df89fbb7.js"><link rel="prefetch" href="/assets/js/54.a140a8dd.js"><link rel="prefetch" href="/assets/js/55.5809711e.js"><link rel="prefetch" href="/assets/js/56.3a62759d.js"><link rel="prefetch" href="/assets/js/57.c9bd4339.js"><link rel="prefetch" href="/assets/js/58.acb475d1.js"><link rel="prefetch" href="/assets/js/59.61cf3322.js"><link rel="prefetch" href="/assets/js/6.73a8f323.js"><link rel="prefetch" href="/assets/js/60.aa39146e.js"><link rel="prefetch" href="/assets/js/61.f62972b8.js"><link rel="prefetch" href="/assets/js/62.79fc1ddc.js"><link rel="prefetch" href="/assets/js/63.808c750c.js"><link rel="prefetch" href="/assets/js/64.4e99e2e1.js"><link rel="prefetch" href="/assets/js/65.f112caec.js"><link rel="prefetch" href="/assets/js/66.422cc6c9.js"><link rel="prefetch" href="/assets/js/67.f504a803.js"><link rel="prefetch" href="/assets/js/68.f8e84a65.js"><link rel="prefetch" href="/assets/js/69.af07ae00.js"><link rel="prefetch" href="/assets/js/7.a6e60d89.js"><link rel="prefetch" href="/assets/js/70.9b212396.js"><link rel="prefetch" href="/assets/js/71.049b7d3e.js"><link rel="prefetch" href="/assets/js/72.b508f834.js"><link rel="prefetch" href="/assets/js/73.52a25a21.js"><link rel="prefetch" href="/assets/js/74.68de4c01.js"><link rel="prefetch" href="/assets/js/75.c0d8e99a.js"><link rel="prefetch" href="/assets/js/76.672b246e.js"><link rel="prefetch" href="/assets/js/77.36d886e3.js"><link rel="prefetch" href="/assets/js/78.079ebfd8.js"><link rel="prefetch" href="/assets/js/79.d3d3e8ea.js"><link rel="prefetch" href="/assets/js/8.a72c567f.js"><link rel="prefetch" href="/assets/js/80.c690c3d9.js"><link rel="prefetch" href="/assets/js/81.c012b7d5.js"><link rel="prefetch" href="/assets/js/82.47ffa460.js"><link rel="prefetch" href="/assets/js/83.2ba84114.js"><link rel="prefetch" href="/assets/js/84.dc0bf5a8.js"><link rel="prefetch" href="/assets/js/85.d968ae8b.js"><link rel="prefetch" href="/assets/js/86.91000a3b.js"><link rel="prefetch" href="/assets/js/87.6e885c71.js"><link rel="prefetch" href="/assets/js/88.99dd2b79.js"><link rel="prefetch" href="/assets/js/89.601c57ea.js"><link rel="prefetch" href="/assets/js/9.c59ba06b.js"><link rel="prefetch" href="/assets/js/90.89ee0da5.js"><link rel="prefetch" href="/assets/js/91.854de449.js"><link rel="prefetch" href="/assets/js/92.7a25d006.js"><link rel="prefetch" href="/assets/js/93.17f89281.js"><link rel="prefetch" href="/assets/js/94.0f6749b9.js"><link rel="prefetch" href="/assets/js/95.41ef6f4a.js"><link rel="prefetch" href="/assets/js/96.12427920.js"><link rel="prefetch" href="/assets/js/97.53036963.js"><link rel="prefetch" href="/assets/js/98.43d8f870.js"><link rel="prefetch" href="/assets/js/99.4ab32fce.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e4d8b86b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/heng.png" alt="英俊的大亨亨" class="logo"> <span class="site-name can-hide">英俊的大亨亨</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">js</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">js</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/js/js-基础.html" class="nav-link">
  基础
</a></li><li class="dropdown-item"><!----> <a href="/js/js-数组.html" class="nav-link">
  数组
</a></li><li class="dropdown-item"><!----> <a href="/js/js-异步.html" class="nav-link">
  异步
</a></li><li class="dropdown-item"><!----> <a href="/js/js-es6.html" class="nav-link">
  es6
</a></li><li class="dropdown-item"><!----> <a href="/js/js-v8引擎.html" class="nav-link">
  v8
</a></li><li class="dropdown-item"><!----> <a href="/手写代码/1.js基础.html" class="nav-link">
  手写
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">前端基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">前端基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          前端基础
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/react/process.html" class="nav-link">
  
</a></li></ul></li><li class="dropdown-item"><!----> <a href="/html.html" class="nav-link">
  html
</a></li><li class="dropdown-item"><!----> <a href="/css.html" class="nav-link">
  css
</a></li><li class="dropdown-item"><!----> <a href="/node.html" class="nav-link">
  node
</a></li><li class="dropdown-item"><!----> <a href="/webpack.html" class="nav-link">
  webpack
</a></li><li class="dropdown-item"><!----> <a href="/webpack.html" class="nav-link">
  小程序
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="leetcode" class="dropdown-title"><span class="title">leetcode</span> <span class="arrow down"></span></button> <button type="button" aria-label="leetcode" class="mobile-dropdown-title"><span class="title">leetcode</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/代码随想录/1.数组.html" class="nav-link">
  1.数组
</a></li><li class="dropdown-item"><!----> <a href="/代码随想录/10.动态规划/1.基础.html" class="nav-link">
  10.动态规划
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">react源码</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">react源码</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/react源码/理念.html" class="nav-link">
  1.理念
</a></li><li class="dropdown-item"><!----> <a href="/react源码/3.render.html" class="nav-link">
  3.render
</a></li><li class="dropdown-item"><!----> <a href="/react源码/4.commit.html" class="nav-link">
  4.commit
</a></li><li class="dropdown-item"><!----> <a href="/react源码/5.状态更新.html" class="nav-link">
  5.状态更新
</a></li><li class="dropdown-item"><!----> <a href="/react源码/6.diff.html" class="nav-link">
  6.diff
</a></li><li class="dropdown-item"><!----> <a href="/react/7.实现hooks.html" class="nav-link">
  7.实现hooks
</a></li><li class="dropdown-item"><!----> <a href="/react/8.concurrentMode.html" class="nav-link">
  8.concurrentMode
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">webpack</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">webpack</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/webpack/1.配置.html" class="nav-link">
  1.配置
</a></li><li class="dropdown-item"><!----> <a href="/webpack/2.loader.html" class="nav-link">
  2.loader
</a></li><li class="dropdown-item"><!----> <a href="/webpack/3.plugin.html" class="nav-link">
  3.plugin
</a></li><li class="dropdown-item"><!----> <a href="/webpack/4.模块化原理.html" class="nav-link">
  4.模块化原理
</a></li><li class="dropdown-item"><!----> <a href="/webpack/5.babel.html" class="nav-link">
  5.babel
</a></li><li class="dropdown-item"><!----> <a href="/webpack/6.HMR.html" class="nav-link">
  6.HMR
</a></li><li class="dropdown-item"><!----> <a href="/webpack/7.环境分离.html" class="nav-link">
  7.环境分离
</a></li><li class="dropdown-item"><!----> <a href="/webpack/8.tree_shaking.html" class="nav-link">
  8.tree_shaking
</a></li><li class="dropdown-item"><!----> <a href="/webpack/9,源码.html" class="nav-link">
  9.源码
</a></li><li class="dropdown-item"><!----> <a href="/webpack/11.自定义loader.html" class="nav-link">
  11.自定义loader
</a></li><li class="dropdown-item"><!----> <a href="/webpack/12.自定义plugin.html" class="nav-link">
  12.自定义plugin
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">前端设计模式</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">前端设计模式</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/设计模式/创建型.html" class="nav-link">
  创建型
</a></li><li class="dropdown-item"><!----> <a href="/设计模式/结构型.html" class="nav-link">
  结构型
</a></li><li class="dropdown-item"><!----> <a href="/设计模式/行为型.html" class="nav-link">
  行为型
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">angular</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">angular</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/JavaScript/.html" class="nav-link">
  angular性能调优
</a></li><li class="dropdown-item"><!----> <a href="/设计模式/结构型.html" class="nav-link">
  angular源码理解
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">健身</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">健身</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/JavaScript/.html" class="nav-link">
  angular性能调优
</a></li><li class="dropdown-item"><!----> <a href="/设计模式/结构型.html" class="nav-link">
  angular源码理解
</a></li></ul></div></div><div class="nav-item"><a href="/me.html" class="nav-link">
  关于我
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">js</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">js</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/js/js-基础.html" class="nav-link">
  基础
</a></li><li class="dropdown-item"><!----> <a href="/js/js-数组.html" class="nav-link">
  数组
</a></li><li class="dropdown-item"><!----> <a href="/js/js-异步.html" class="nav-link">
  异步
</a></li><li class="dropdown-item"><!----> <a href="/js/js-es6.html" class="nav-link">
  es6
</a></li><li class="dropdown-item"><!----> <a href="/js/js-v8引擎.html" class="nav-link">
  v8
</a></li><li class="dropdown-item"><!----> <a href="/手写代码/1.js基础.html" class="nav-link">
  手写
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">前端基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">前端基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          前端基础
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/react/process.html" class="nav-link">
  
</a></li></ul></li><li class="dropdown-item"><!----> <a href="/html.html" class="nav-link">
  html
</a></li><li class="dropdown-item"><!----> <a href="/css.html" class="nav-link">
  css
</a></li><li class="dropdown-item"><!----> <a href="/node.html" class="nav-link">
  node
</a></li><li class="dropdown-item"><!----> <a href="/webpack.html" class="nav-link">
  webpack
</a></li><li class="dropdown-item"><!----> <a href="/webpack.html" class="nav-link">
  小程序
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="leetcode" class="dropdown-title"><span class="title">leetcode</span> <span class="arrow down"></span></button> <button type="button" aria-label="leetcode" class="mobile-dropdown-title"><span class="title">leetcode</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/代码随想录/1.数组.html" class="nav-link">
  1.数组
</a></li><li class="dropdown-item"><!----> <a href="/代码随想录/10.动态规划/1.基础.html" class="nav-link">
  10.动态规划
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">react源码</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">react源码</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/react源码/理念.html" class="nav-link">
  1.理念
</a></li><li class="dropdown-item"><!----> <a href="/react源码/3.render.html" class="nav-link">
  3.render
</a></li><li class="dropdown-item"><!----> <a href="/react源码/4.commit.html" class="nav-link">
  4.commit
</a></li><li class="dropdown-item"><!----> <a href="/react源码/5.状态更新.html" class="nav-link">
  5.状态更新
</a></li><li class="dropdown-item"><!----> <a href="/react源码/6.diff.html" class="nav-link">
  6.diff
</a></li><li class="dropdown-item"><!----> <a href="/react/7.实现hooks.html" class="nav-link">
  7.实现hooks
</a></li><li class="dropdown-item"><!----> <a href="/react/8.concurrentMode.html" class="nav-link">
  8.concurrentMode
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">webpack</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">webpack</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/webpack/1.配置.html" class="nav-link">
  1.配置
</a></li><li class="dropdown-item"><!----> <a href="/webpack/2.loader.html" class="nav-link">
  2.loader
</a></li><li class="dropdown-item"><!----> <a href="/webpack/3.plugin.html" class="nav-link">
  3.plugin
</a></li><li class="dropdown-item"><!----> <a href="/webpack/4.模块化原理.html" class="nav-link">
  4.模块化原理
</a></li><li class="dropdown-item"><!----> <a href="/webpack/5.babel.html" class="nav-link">
  5.babel
</a></li><li class="dropdown-item"><!----> <a href="/webpack/6.HMR.html" class="nav-link">
  6.HMR
</a></li><li class="dropdown-item"><!----> <a href="/webpack/7.环境分离.html" class="nav-link">
  7.环境分离
</a></li><li class="dropdown-item"><!----> <a href="/webpack/8.tree_shaking.html" class="nav-link">
  8.tree_shaking
</a></li><li class="dropdown-item"><!----> <a href="/webpack/9,源码.html" class="nav-link">
  9.源码
</a></li><li class="dropdown-item"><!----> <a href="/webpack/11.自定义loader.html" class="nav-link">
  11.自定义loader
</a></li><li class="dropdown-item"><!----> <a href="/webpack/12.自定义plugin.html" class="nav-link">
  12.自定义plugin
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">前端设计模式</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">前端设计模式</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/设计模式/创建型.html" class="nav-link">
  创建型
</a></li><li class="dropdown-item"><!----> <a href="/设计模式/结构型.html" class="nav-link">
  结构型
</a></li><li class="dropdown-item"><!----> <a href="/设计模式/行为型.html" class="nav-link">
  行为型
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">angular</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">angular</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/JavaScript/.html" class="nav-link">
  angular性能调优
</a></li><li class="dropdown-item"><!----> <a href="/设计模式/结构型.html" class="nav-link">
  angular源码理解
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">健身</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">健身</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/JavaScript/.html" class="nav-link">
  angular性能调优
</a></li><li class="dropdown-item"><!----> <a href="/设计模式/结构型.html" class="nav-link">
  angular源码理解
</a></li></ul></div></div><div class="nav-item"><a href="/me.html" class="nav-link">
  关于我
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Java Script</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/JavaScript/1.数据类型.html" class="sidebar-link">1. JavaScript的8种类型</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/JavaScript/2.es6.html" class="sidebar-link">1. let、const、var的区别</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/JavaScript/3.基础.html" class="sidebar-link">1. new操作符的实现原理</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/JavaScript/4.原型链.html" class="sidebar-link">1. 对原型、原型链的理解</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/JavaScript/5.作用域.html" class="sidebar-link">五、执行上下文/作用域链/闭包</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/JavaScript/5.作用域.html#五、执行上下文-作用域链-闭包" class="sidebar-link">五、执行上下文/作用域链/闭包</a></li></ul></li><li><a href="/JavaScript/6.thiscall.html" class="sidebar-link">1. 对this对象的理解</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/JavaScript/7.异步编程.html" class="sidebar-link">七、异步编程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/JavaScript/7.异步编程.html#七、异步编程" class="sidebar-link">七、异步编程</a></li><li class="sidebar-sub-header"><a href="/JavaScript/7.异步编程.html#八、面向对象" class="sidebar-link">八、面向对象</a></li><li class="sidebar-sub-header"><a href="/JavaScript/7.异步编程.html#九、垃圾回收与内存泄漏" class="sidebar-link">九、垃圾回收与内存泄漏</a></li></ul></li><li><a href="/JavaScript/事件循环.html" class="sidebar-link">/JavaScript/事件循环.html</a></li><li><a href="/JavaScript/基础知识.html" class="sidebar-link">generator</a></li><li><a href="/JavaScript/模块化.html" class="sidebar-link">什么是模块</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/JavaScript/模块化.html#什么是模块" class="sidebar-link">什么是模块</a></li><li class="sidebar-sub-header"><a href="/JavaScript/模块化.html#commonjs" class="sidebar-link">CommonJS</a></li><li class="sidebar-sub-header"><a href="/JavaScript/模块化.html#amd" class="sidebar-link">AMD</a></li><li class="sidebar-sub-header"><a href="/JavaScript/模块化.html#cmd" class="sidebar-link">CMD</a></li><li class="sidebar-sub-header"><a href="/JavaScript/模块化.html#cmd与amd区别" class="sidebar-link">CMD与AMD区别</a></li><li class="sidebar-sub-header"><a href="/JavaScript/模块化.html#es6模块化" class="sidebar-link">ES6模块化</a></li><li class="sidebar-sub-header"><a href="/JavaScript/模块化.html#es6-模块与-commonjs-模块的差异" class="sidebar-link">ES6 模块与 CommonJS 模块的差异</a></li><li class="sidebar-sub-header"><a href="/JavaScript/模块化.html#总结" class="sidebar-link">总结</a></li></ul></li><li><a href="/JavaScript/深浅拷贝.html" class="sidebar-link">/JavaScript/深浅拷贝.html</a></li><li><a href="/JavaScript/面试-js.html" class="sidebar-link">1、原型和原型链</a></li><li><a href="/JavaScript/面试-react.html" class="active sidebar-link">/JavaScript/面试-react.html</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/JavaScript/面试-服务器网络.html" class="sidebar-link">/JavaScript/面试-服务器网络.html</a></li><li><a href="/JavaScript/面试-浏览器.html" class="sidebar-link">/JavaScript/面试-浏览器.html</a></li><li><a href="/JavaScript/面试-锦怡.html" class="sidebar-link">/JavaScript/面试-锦怡.html</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><ol><li>Fiber</li></ol> <p>React 的核心流程分为reconciliation （render）调度和commit</p> <p>reconciliation <strong>render</strong></p> <ul><li>更新 state 与 props</li> <li>调用生命周期钩子</li> <li>生成 Fiber Tree</li> <li>diff 算法，获取 vdom change</li> <li>确定是否需要重新渲染</li></ul> <p><strong>commit</strong></p> <ul><li>操作 dom 节点更新；</li></ul> <p><strong>对Fiber的认识：</strong></p> <p>React16的Fiber之前，更新是无法中断的，所以大量的组件渲染时，主进程会长期占用同步阻塞，造成页面卡顿掉帧。</p> <p>为了实现可中断更新，改变调度reconciler，从stack改成fiber，将一次同步更新任务分割成多个小任务，以fiber为更小的任务单位承载渲染，实现更新的可中断特性。</p> <p>fiber如何实现更新可中断呢</p> <p><strong>核心</strong>:</p> <ul><li><p>Fiber 具象为一个 <strong>数据结构</strong>，有child、return、sibling指针，通过指针连接形成一个Fiber树</p></li> <li><p>Fiber树的遍历算法，遍历过程对节点保存和映射实现随时的停止和回复，从而支持任务分割的特性。</p></li> <li><p><strong>链表树遍历算法</strong>: 通过 <strong>节点保存与映射</strong>，便能够随时地进行 停止和重启，这样便能达到实现任务分割的基本前提；</p> <ul><li>1、首先通过不断遍历子节点，到树末尾；</li> <li>2、开始通过 sibling 遍历兄弟节点；</li> <li>3、return 返回父节点，继续执行2；</li> <li>4、直到 root 节点后，跳出遍历；</li></ul></li> <li><p><strong>任务分割</strong>，React 中的渲染更新可以分成两个阶段:</p> <ul><li><strong>reconciliation 阶段</strong>: vdom 的数据对比，是个适合拆分的阶段，比如对比一部分树后，先暂停执行个动画调用，待完成后再回来继续比对。</li> <li><strong>Commit 阶段</strong>: 将 change list 更新到 dom 上，并不适合拆分，才能保持数据与 UI 的同步。否则可能由于阻塞 UI 更新，而导致数据更新和 UI 不一致的情况。</li></ul></li> <li><p><strong>分散执行</strong>: 任务分割后，就可以把小任务单元分散到浏览器的空闲期间去排队执行，而实现的关键是两个新API: <code>requestIdleCallback</code> 与 <code>requestAnimationFrame</code></p> <ul><li>低优先级的任务交给<code>requestIdleCallback</code>处理，这是个浏览器提供的事件循环空闲期的回调函数，需要 pollyfill，而且拥有 deadline 参数，限制执行事件，以继续切分任务；</li> <li>高优先级的任务交给<code>requestAnimationFrame</code>处理；</li></ul></li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 类似于这样的方式
requestIdleCallback((deadline) =&gt; {
    // 当有空闲时间时，我们执行一个组件渲染；
    // 把任务塞到一个个碎片时间中去；
    while ((deadline.timeRemaining() &gt; 0 || deadline.didTimeout) &amp;&amp; nextComponent) {
        nextComponent = performWork(nextComponent);
    }
});
复制代码
</code></pre></div><ul><li><strong>优先级策略</strong>: 文本框输入 &gt; 本次调度结束需完成的任务 &gt; 动画过渡 &gt; 交互反馈 &gt; 数据更新 &gt; 不会显示但以防将来会显示的任务</li></ul> <h3 id="_2-生命周期"><a href="#_2-生命周期" class="header-anchor">#</a> 2. 生命周期</h3> <p>因为fiber架构出现，生命周期的新<strong>变动</strong>:</p> <ul><li><p>使用<code>getDerivedStateFromProps</code> 替换 <code>componentWillMount</code> 与 <code>componentWillReceiveProps</code>；</p></li> <li><p>使用<code>getSnapshotBeforeUpdate</code>替换<code>componentWillUpdate</code>；</p></li> <li><p>避免使用<code>componentWillReceiveProps</code>；</p></li> <li><p>** reconciliation**:</p> <ul><li><code>componentWillMount</code></li> <li><code>componentWillReceiveProps</code></li> <li><code>shouldComponentUpdate</code></li> <li><code>componentWillUpdate</code></li></ul></li> <li><p><strong>commit</strong>:</p> <ul><li><code>componentDidMount</code></li> <li><code>componentDidUpdate</code></li> <li><code>componentWillUnmount</code></li></ul></li></ul> <p>在 Fiber 中，reconciliation 阶段进行了任务分割，涉及到 暂停 和 重启，因此可能会导致 reconciliation 中的生命周期函数在一次更新渲染循环中被 <strong>多次调用</strong> 的情况，产生一些意外错误。</p> <p>新版的建议生命周期如下:</p> <div class="language- extra-class"><pre class="language-text"><code>class Component extends React.Component {
  // 替换 `componentWillReceiveProps` ，
  // 初始化和 update 时被调用
  // 静态函数，无法使用 this
  static getDerivedStateFromProps(nextProps, prevState) {}
  
  // 判断是否需要更新组件
  // 可以用于组件性能优化
  shouldComponentUpdate(nextProps, nextState) {}
  
  // 组件被挂载后触发
  componentDidMount() {}
  
  // 替换 componentWillUpdate
  // 可以在更新之前获取最新 dom 数据
  getSnapshotBeforeUpdate() {}
  
  // 组件更新后调用
  componentDidUpdate() {}
  
  // 组件即将销毁
  componentWillUnmount() {}
  
  // 组件已销毁
  componentDidUnmount() {}
}
复制代码
</code></pre></div><ul><li><p><strong>使用建议</strong>:</p> <ul><li><p>在<code>constructor</code>初始化 state；</p></li> <li><p>在<code>componentDidMount</code>中进行事件监听，并在<code>componentWillUnmount</code>中解绑事件；</p></li> <li><p>在<code>componentDidMount</code>中进行数据的请求，而不是在<code>componentWillMount</code>；</p></li> <li><p>需要根据 props 更新 state 时，使用</p> <div class="language- extra-class"><pre class="language-text"><code>getDerivedStateFromProps(nextProps, prevState)
</code></pre></div><ul><li>旧 props 需要自己存储，以便比较；</li></ul></li></ul> <div class="language- extra-class"><pre class="language-text"><code>public static getDerivedStateFromProps(nextProps, prevState) {
	// 当新 props 中的 data 发生变化时，同步更新到 state 上
	if (nextProps.data !== prevState.data) {
		return {
			data: nextProps.data
		}
	} else {
		return null1
	}
}
复制代码
</code></pre></div><ul><li>可以在<code>componentDidUpdate</code>监听 props 或者 state 的变化，例如:</li></ul> <div class="language- extra-class"><pre class="language-text"><code>componentDidUpdate(prevProps) {
	// 当 id 发生变化时，重新获取数据
	if (this.props.id !== prevProps.id) {
		this.fetchData(this.props.id);
	}
}
复制代码
</code></pre></div><ul><li>在<code>componentDidUpdate</code>使用<code>setState</code>时，必须加条件，否则将进入死循环；</li> <li><code>getSnapshotBeforeUpdate(prevProps, prevState)</code>可以在更新之前获取最新的渲染数据，它的调用是在 render 之后， update 之前；</li> <li><code>shouldComponentUpdate</code>: 默认每次调用<code>setState</code>，一定会最终走到 diff 阶段，但可以通过<code>shouldComponentUpdate</code>的生命钩子返回<code>false</code>来直接阻止后面的逻辑执行，通常是用于做条件渲染，优化渲染的性能。</li></ul></li></ul> <h3 id="_3-setstate"><a href="#_3-setstate" class="header-anchor">#</a> 3. setState</h3> <p>在了解<code>setState</code>之前，我们先来简单了解下 React 一个包装结构: <strong>Transaction</strong>:</p> <ul><li><p>事务</p> <p>(Transaction):</p> <ul><li>是 React 中的一个调用结构，用于包装一个方法，结构为: <strong>initialize - perform(method) - close</strong>。通过事务，可以统一管理一个方法的开始与结束；处于事务流中，表示进程正在执行一些操作；</li></ul></li></ul> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/21/1699e0cb48cd4013~tplv-t2oaga2asx-watermark.awebp" alt="img"></p> <ul><li><p><code>setState</code>: React 中用于修改状态，更新视图。它具有以下特点:</p></li> <li><p><strong>异步与同步</strong>: <code>setState</code>并不是单纯的异步或同步，这其实与调用时的环境相关:</p> <ul><li><p>在</p> <p>合成事件</p> <p>和</p> <p>生命周期钩子(除 componentDidUpdate)</p> <p>中，</p> <div class="language- extra-class"><pre class="language-text"><code>setState
</code></pre></div><p>是&quot;异步&quot;的；</p> <ul><li><p>原因</p> <p>: 因为在</p> <div class="language- extra-class"><pre class="language-text"><code>setState
</code></pre></div><p>的实现中，有一个判断: 当更新策略正在事务流的执行中时，该组件更新会被推入</p> <div class="language- extra-class"><pre class="language-text"><code>dirtyComponents
</code></pre></div><p>队列中等待执行；否则，开始执行</p> <div class="language- extra-class"><pre class="language-text"><code>batchedUpdates
</code></pre></div><p>队列更新；</p> <ul><li>在生命周期钩子调用中，更新策略都处于更新之前，组件仍处于事务流中，而<code>componentDidUpdate</code>是在更新之后，此时组件已经不在事务流中了，因此则会同步执行；</li> <li>在合成事件中，React 是基于 <strong>事务流完成的事件委托机制</strong> 实现，也是处于事务流中；</li></ul></li> <li><p><strong>问题</strong>: 无法在<code>setState</code>后马上从<code>this.state</code>上获取更新后的值。</p></li> <li><p><strong>解决</strong>: 如果需要马上同步去获取新值，<code>setState</code>其实是可以传入第二个参数的。<code>setState(updater, callback)</code>，在回调中即可获取最新值；</p></li></ul></li> <li><p>在</p> <p>原生事件</p> <p>和</p> <p>setTimeout</p> <p>中，</p> <div class="language- extra-class"><pre class="language-text"><code>setState
</code></pre></div><p>是同步的，可以马上获取更新后的值；</p> <ul><li>原因: 原生事件是浏览器本身的实现，与事务流无关，自然是同步；而<code>setTimeout</code>是放置于定时器线程中延后执行，此时事务流已结束，因此也是同步；</li></ul></li></ul></li> <li><p><strong>批量更新</strong>: 在 <strong>合成事件</strong> 和 <strong>生命周期钩子</strong> 中，<code>setState</code>更新队列时，存储的是 <strong>合并状态</strong>(<code>Object.assign</code>)。因此前面设置的 key 值会被后面所覆盖，最终只会执行一次更新；</p></li> <li><p><strong>函数式</strong>: 由于 Fiber 及 合并 的问题，官方推荐可以传入 <strong>函数</strong> 的形式。<code>setState(fn)</code>，在<code>fn</code>中返回新的<code>state</code>对象即可，例如<code>this.setState((state, props) =&gt; newState)；</code></p> <ul><li>使用函数式，可以用于避免<code>setState</code>的批量更新的逻辑，传入的函数将会被 <strong>顺序调用</strong>；</li></ul></li> <li><p><strong>注意事项</strong>:</p> <ul><li><p>setState 合并，在 合成事件 和 生命周期钩子 中多次连续调用会被优化为一次；</p></li> <li><p>当组件已被销毁，如果再次调用</p> <div class="language- extra-class"><pre class="language-text"><code>setState
</code></pre></div><p>，React 会报错警告，通常有两种解决办法:</p> <ul><li>将数据挂载到外部，通过 props 传入，如放到 Redux 或 父级中；</li> <li>在组件内部维护一个状态量 (isUnmounted)，<code>componentWillUnmount</code>中标记为 true，在<code>setState</code>前进行判断；</li></ul></li></ul></li></ul> <h3 id="_4-hoc-高阶组件"><a href="#_4-hoc-高阶组件" class="header-anchor">#</a> 4. HOC(高阶组件)</h3> <p>HOC(Higher Order Componennt) 是在 React 机制下社区形成的一种组件模式，在很多第三方开源库中表现强大。</p> <ul><li><p><strong>简述</strong>:</p> <ul><li>高阶组件不是组件，是 <strong>增强函数</strong>，可以输入一个元组件，返回出一个新的增强组件；</li> <li>高阶组件的主要作用是 <strong>代码复用</strong>，<strong>操作</strong> 状态和参数；</li></ul></li> <li><p><strong>用法</strong>:</p> <ul><li><p><strong>属性代理 (Props Proxy)</strong>: 返回出一个组件，它基于被包裹组件进行 <strong>功能增强</strong>；</p> <ul><li><strong>默认参数</strong>: 可以为组件包裹一层默认参数；</li></ul> <div class="language- extra-class"><pre class="language-text"><code>function proxyHoc(Comp) {
	return class extends React.Component {
		render() {
			const newProps = {
				name: 'tayde',
				age: 1,
			}
			return &lt;Comp {...this.props} {...newProps} /&gt;
		}
	}
}
复制代码
</code></pre></div><ul><li><strong>提取状态</strong>: 可以通过 props 将被包裹组件中的 state 依赖外层，例如用于转换受控组件:</li></ul> <div class="language- extra-class"><pre class="language-text"><code>function withOnChange(Comp) {
	return class extends React.Component {
		constructor(props) {
			super(props)
			this.state = {
				name: '',
			}
		}
		onChangeName = () =&gt; {
			this.setState({
				name: 'dongdong',
			})
		}
		render() {
			const newProps = {
				value: this.state.name,
				onChange: this.onChangeName,
			}
			return &lt;Comp {...this.props} {...newProps} /&gt;
		}
	}
}
复制代码
</code></pre></div><p>使用姿势如下，这样就能非常快速的将一个 <code>Input</code> 组件转化成受控组件。</p> <div class="language- extra-class"><pre class="language-text"><code>const NameInput = props =&gt; (&lt;input name=&quot;name&quot; {...props} /&gt;)
export default withOnChange(NameInput)
复制代码
</code></pre></div><ul><li><strong>包裹组件</strong>: 可以为被包裹元素进行一层包装，</li></ul> <div class="language- extra-class"><pre class="language-text"><code>function withMask(Comp) {
  return class extends React.Component {
      render() {
		  return (
		      &lt;div&gt;
				  &lt;Comp {...this.props} /&gt;
					&lt;div style={{
					  width: '100%',
					  height: '100%',
					  backgroundColor: 'rgba(0, 0, 0, .6)',
				  }} 
			  &lt;/div&gt;
		  )
	  }
  }
}
复制代码
</code></pre></div></li> <li><p><strong>反向继承</strong> (Inheritance Inversion): 返回出一个组件，<strong>继承于被包裹组件</strong>，常用于以下操作:</p> <div class="language- extra-class"><pre class="language-text"><code>function IIHoc(Comp) {
    return class extends Comp {
        render() {
            return super.render();
        }
    };
}
复制代码
</code></pre></div><ul><li><p><strong>渲染劫持</strong> (Render Highjacking)</p> <ul><li><strong>条件渲染</strong>: 根据条件，渲染不同的组件</li></ul> <div class="language- extra-class"><pre class="language-text"><code>function withLoading(Comp) {
    return class extends Comp {
        render() {
            if(this.props.isLoading) {
                return &lt;Loading /&gt;
            } else {
                return super.render()
            }
        }
    };
}
复制代码
</code></pre></div><ul><li>可以直接修改被包裹组件渲染出的 React 元素树</li></ul></li> <li><p><strong>操作状态</strong> (Operate State): 可以直接通过 <code>this.state</code> 获取到被包裹组件的状态，并进行操作。但这样的操作容易使 state 变得难以追踪，不易维护，谨慎使用。</p></li></ul></li></ul></li> <li><p><strong>应用场景</strong>:</p> <ul><li><strong>权限控制</strong>，通过抽象逻辑，统一对页面进行权限判断，按不同的条件进行页面渲染:</li></ul> <div class="language- extra-class"><pre class="language-text"><code>function withAdminAuth(WrappedComponent) {
    return class extends React.Component {
		constructor(props){
			super(props)
			this.state = {
		    	isAdmin: false,
			}
		} 
		async componentWillMount() {
		    const currentRole = await getCurrentUserRole();
		    this.setState({
		        isAdmin: currentRole === 'Admin',
		    });
		}
		render() {
		    if (this.state.isAdmin) {
		        return &lt;Comp {...this.props} /&gt;;
		    } else {
		        return (&lt;div&gt;您没有权限查看该页面，请联系管理员！&lt;/div&gt;);
		    }
		}
    };
}
复制代码
</code></pre></div><ul><li><strong>性能监控</strong>，包裹组件的生命周期，进行统一埋点:</li></ul> <div class="language- extra-class"><pre class="language-text"><code>function withTiming(Comp) {
    return class extends Comp {
        constructor(props) {
            super(props);
            this.start = Date.now();
            this.end = 0;
        }
        componentDidMount() {
            super.componentDidMount &amp;&amp; super.componentDidMount();
            this.end = Date.now();
            console.log(`${WrappedComponent.name} 组件渲染时间为 ${this.end - this.start} ms`);
        }
        render() {
            return super.render();
        }
    };
}
复制代码
</code></pre></div><ul><li><strong>代码复用</strong>，可以将重复的逻辑进行抽象。</li></ul></li> <li><p>使用注意:</p> <ul><li><ol><li><strong>纯函数</strong>: 增强函数应为纯函数，避免侵入修改元组件；</li></ol></li> <li><ol><li><strong>避免用法污染</strong>: 理想状态下，应透传元组件的无关参数与事件，尽量保证用法不变；</li></ol></li> <li><ol><li><strong>命名空间</strong>: 为 HOC 增加特异性的组件名称，这样能便于开发调试和查找问题；</li></ol></li> <li><ol><li><strong>引用传递</strong>: 如果需要传递元组件的 refs 引用，可以使用<code>React.forwardRef</code>；</li></ol></li> <li><ol><li><strong>静态方法</strong>: 元组件上的静态方法并无法被自动传出，会导致业务层无法调用；解决:</li></ol> <ul><li>函数导出</li> <li>静态方法赋值</li></ul></li> <li><ol><li><strong>重新渲染</strong>: 由于增强函数每次调用是返回一个新组件，因此如果在 Render 中使用增强函数，就会导致每次都重新渲染整个HOC，而且之前的状态会丢失；</li></ol></li></ul></li></ul> <h3 id="_5-redux"><a href="#_5-redux" class="header-anchor">#</a> 5. Redux</h3> <p>Redux 是一个 <strong>数据管理中心</strong>，可以把它理解为一个全局的 data store 实例。它通过一定的使用规则和限制，保证着数据的健壮性、可追溯和可预测性。它与 React 无关，可以独立运行于任何 JavaScript 环境中，从而也为同构应用提供了更好的数据同步通道。</p> <ul><li><p><strong>核心理念</strong>:</p> <ul><li><p><strong>单一数据源</strong>: 整个应用只有唯一的状态树，也就是所有 state 最终维护在一个根级 Store 中；</p></li> <li><p>状态只读</p> <p>: 为了保证状态的可控性，最好的方式就是监控状态的变化。那这里就两个必要条件：</p> <ul><li>Redux Store 中的数据无法被直接修改；</li> <li>严格控制修改的执行；</li></ul></li> <li><p><strong>纯函数</strong>: 规定只能通过一个纯函数 (Reducer) 来描述修改；</p></li></ul></li> <li><p>大致的数据结构如下所示:</p></li></ul> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/21/1699e0d09c40cec7~tplv-t2oaga2asx-watermark.awebp" alt="img"></p> <ul><li><p><strong>理念实现</strong>:</p> <ul><li><p>Store</p> <p>: 全局 Store 单例， 每个 Redux 应用下只有一个 store， 它具有以下方法供使用:</p> <ul><li><code>getState</code>: 获取 state；</li> <li><code>dispatch</code>: 触发 action, 更新 state；</li> <li><code>subscribe</code>: 订阅数据变更，注册监听器；</li></ul></li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 创建
const store = createStore(Reducer, initStore)
复制代码
</code></pre></div><ul><li><strong>Action</strong>: 它作为一个行为载体，用于映射相应的 Reducer，并且它可以成为数据的载体，将数据从应用传递至 store 中，是 store <strong>唯一的数据源</strong>；</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 一个普通的 Action
const action = {
	type: 'ADD_LIST',
	item: 'list-item-1',
}

// 使用：
store.dispatch(action)

// 通常为了便于调用，会有一个 Action 创建函数 (action creater)
funtion addList(item) {
	return const action = {
		type: 'ADD_LIST',
		item,
	}
}

// 调用就会变成:
dispatch(addList('list-item-1'))
复制代码
</code></pre></div><ul><li><strong>Reducer</strong>: 用于描述如何修改数据的纯函数，Action 属于行为名称，而 Reducer 便是修改行为的实质；</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 一个常规的 Reducer
// @param {state}: 旧数据
// @param {action}: Action 对象
// @returns {any}: 新数据
const initList = []
function ListReducer(state = initList, action) {
	switch (action.type) {
		case 'ADD_LIST':
			return state.concat([action.item])
			break
		defalut:
			return state
	}
}
复制代码
</code></pre></div><blockquote><p><strong>注意</strong>:</p> <ol><li>遵守数据不可变，不要去直接修改 state，而是返回出一个 <strong>新对象</strong>，可以使用 <code>assign / copy / extend / 解构</code> 等方式创建新对象；</li> <li>默认情况下需要 <strong>返回原数据</strong>，避免数据被清空；</li> <li>最好设置 <strong>初始值</strong>，便于应用的初始化及数据稳定；</li></ol></blockquote></li> <li><p><strong>进阶</strong>:</p> <ul><li><p>React-Redux</p> <p>: 结合 React 使用；</p> <ul><li><p><code>&lt;Provider&gt;</code>: 将 store 通过 context 传入组件中；</p></li> <li><div class="language- extra-class"><pre class="language-text"><code>connect
</code></pre></div><p>: 一个高阶组件，可以方便在 React 组件中使用 Redux；</p> <ul><li><ol><li>将<code>store</code>通过<code>mapStateToProps</code>进行筛选后使用<code>props</code>注入组件</li></ol></li> <li><ol><li>根据<code>mapDispatchToProps</code>创建方法，当组件调用时使用<code>dispatch</code>触发对应的<code>action</code></li></ol></li></ul></li></ul></li> <li><p>Reducer 的拆分与重构</p> <p>:</p> <ul><li>随着项目越大，如果将所有状态的 reducer 全部写在一个函数中，将会 <strong>难以维护</strong>；</li> <li>可以将 reducer 进行拆分，也就是 <strong>函数分解</strong>，最终再使用<code>combineReducers()</code>进行重构合并；</li></ul></li> <li><p>异步 Action</p> <p>: 由于 Reducer 是一个严格的纯函数，因此无法在 Reducer 中进行数据的请求，需要先获取数据，再</p> <div class="language- extra-class"><pre class="language-text"><code>dispatch(Action)
</code></pre></div><p>即可，下面是三种不同的异步实现:</p> <ul><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Freduxjs%2Fredux-thunk" target="_blank" rel="noopener noreferrer">redex-thunk<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fredux-saga%2Fredux-saga" target="_blank" rel="noopener noreferrer">redux-saga<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fredux-observable%2Fredux-observable" target="_blank" rel="noopener noreferrer">redux-observable<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li></ul></li></ul> <h3 id="_6-react-hooks"><a href="#_6-react-hooks" class="header-anchor">#</a> 6. React Hooks</h3> <p>React 中通常使用 <strong>类定义</strong> 或者 <strong>函数定义</strong> 创建组件:</p> <p>在类定义中，我们可以使用到许多 React 特性，例如 state、 各种组件生命周期钩子等，但是在函数定义中，我们却无能为力，因此 React 16.8 版本推出了一个新功能 (React Hooks)，通过它，可以更好的在函数定义组件中使用 React 特性。</p> <ul><li><p><strong>好处</strong>:</p> <ul><li><p>1、<strong>跨组件复用</strong>: 其实 render props / HOC 也是为了复用，相比于它们，Hooks 作为官方的底层 API，最为轻量，而且改造成本小，不会影响原来的组件层次结构和传说中的嵌套地狱；</p></li> <li><p>2、</p> <p>类定义更为复杂</p> <p>:</p> <ul><li>不同的生命周期会使逻辑变得分散且混乱，不易维护和管理；</li> <li>时刻需要关注<code>this</code>的指向问题；</li> <li>代码复用代价高，高阶组件的使用经常会使整个组件树变得臃肿；</li></ul></li> <li><p>3、<strong>状态与UI隔离</strong>: 正是由于 Hooks 的特性，状态逻辑会变成更小的粒度，并且极容易被抽象成一个自定义 Hooks，组件中的状态和 UI 变得更为清晰和隔离。</p></li></ul></li> <li><p><strong>注意</strong>:</p> <ul><li>避免在 循环/条件判断/嵌套函数 中调用 hooks，保证调用顺序的稳定；</li> <li>只有 函数定义组件 和 hooks 可以调用 hooks，避免在 类组件 或者 普通函数 中调用；</li> <li>不能在<code>useEffect</code>中使用<code>useState</code>，React 会报错提示；</li> <li>类组件不会被替换或废弃，不需要强制改造类组件，两种方式能并存；</li></ul></li> <li><p><strong>重要钩子</strong>*:</p> <ul><li><strong>状态钩子</strong> (<code>useState</code>): 用于定义组件的 State，其到类定义中<code>this.state</code>的功能；</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// useState 只接受一个参数: 初始状态
// 返回的是组件名和更改该组件对应的函数
const [flag, setFlag] = useState(true);
// 修改状态
setFlag(false)
	
// 上面的代码映射到类定义中:
this.state = {
	flag: true	
}
const flag = this.state.flag
const setFlag = (bool) =&gt; {
    this.setState({
        flag: bool,
    })
}
复制代码
</code></pre></div><ul><li><strong>生命周期钩子</strong> (<code>useEffect</code>):</li></ul> <p>类定义中有许多生命周期函数，而在 React Hooks 中也提供了一个相应的函数 (<code>useEffect</code>)，这里可以看做<code>componentDidMount</code>、<code>componentDidUpdate</code>和<code>componentWillUnmount</code>的结合。</p> <ul><li><div class="language- extra-class"><pre class="language-text"><code>useEffect(callback, [source])
</code></pre></div><p>接受两个参数</p> <ul><li><code>callback</code>: 钩子回调函数；</li> <li><code>source</code>: 设置触发条件，仅当 source 发生改变时才会触发；</li> <li><code>useEffect</code>钩子在没有传入<code>[source]</code>参数时，默认在每次 render 时都会优先调用上次保存的回调中返回的函数，后再重新调用回调；</li></ul></li></ul> <div class="language- extra-class"><pre class="language-text"><code>useEffect(() =&gt; {
	// 组件挂载后执行事件绑定
	console.log('on')
	addEventListener()
	
	// 组件 update 时会执行事件解绑
	return () =&gt; {
		console.log('off')
		removeEventListener()
	}
}, [source]);


// 每次 source 发生改变时，执行结果(以类定义的生命周期，便于大家理解):
// --- DidMount ---
// 'on'
// --- DidUpdate ---
// 'off'
// 'on'
// --- DidUpdate ---
// 'off'
// 'on'
// --- WillUnmount --- 
// 'off'
复制代码
</code></pre></div><ul><li><p>通过第二个参数，我们便可模拟出几个常用的生命周期:</p> <ul><li><code>componentDidMount</code>: 传入<code>[]</code>时，就只会在初始化时调用一次；</li></ul> <div class="language- extra-class"><pre class="language-text"><code>const useMount = (fn) =&gt; useEffect(fn, [])
复制代码
</code></pre></div><ul><li><code>componentWillUnmount</code>: 传入<code>[]</code>，回调中的返回的函数也只会被最终执行一次；</li></ul> <div class="language- extra-class"><pre class="language-text"><code>const useUnmount = (fn) =&gt; useEffect(() =&gt; fn, [])
复制代码
</code></pre></div><ul><li><code>mounted</code>: 可以使用 useState 封装成一个高度可复用的 mounted 状态；</li></ul> <div class="language- extra-class"><pre class="language-text"><code>const useMounted = () =&gt; {
    const [mounted, setMounted] = useState(false);
    useEffect(() =&gt; {
        !mounted &amp;&amp; setMounted(true);
        return () =&gt; setMounted(false);
    }, []);
    return mounted;
}
复制代码
</code></pre></div><ul><li><code>componentDidUpdate</code>: <code>useEffect</code>每次均会执行，其实就是排除了 DidMount 后即可；</li></ul> <div class="language- extra-class"><pre class="language-text"><code>const mounted = useMounted() 
useEffect(() =&gt; {
    mounted &amp;&amp; fn()
})
复制代码
</code></pre></div></li></ul></li> <li><p><strong>其它内置钩子</strong>:</p> <ul><li><code>useContext</code>: 获取 context 对象</li> <li><code>useReducer</code>: 类似于 Redux 思想的实现，但其并不足以替代 Redux，可以理解成一个组件内部的 redux:
<ul><li>并不是持久化存储，会随着组件被销毁而销毁；</li> <li>属于组件内部，各个组件是相互隔离的，单纯用它并无法共享数据；</li> <li>配合<code>useContext</code>的全局性，可以完成一个轻量级的 Redux；(<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fctrlplusb%2Feasy-peasy" target="_blank" rel="noopener noreferrer">easy-peasy<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>)</li></ul></li> <li><code>useCallback</code>: 缓存回调函数，避免传入的回调每次都是新的函数实例而导致依赖组件重新渲染，具有性能优化的效果；</li> <li><code>useMemo</code>: 用于缓存传入的 props，避免依赖的组件每次都重新渲染；</li> <li><code>useRef</code>: 获取组件的真实节点；</li> <li><code>useLayoutEffect</code>:
<ul><li>DOM更新同步钩子。用法与<code>useEffect</code>类似，只是区别于执行时间点的不同。</li> <li><code>useEffect</code>属于异步执行，并不会等待 DOM 真正渲染后执行，而<code>useLayoutEffect</code>则会真正渲染后才触发；</li> <li>可以获取更新后的 state；</li></ul></li></ul></li> <li><p><strong>自定义钩子</strong>(<code>useXxxxx</code>): 基于 Hooks 可以引用其它 Hooks 这个特性，我们可以编写自定义钩子，如上面的<code>useMounted</code>。又例如，我们需要每个页面自定义标题:</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function useTitle(title) {
  useEffect(
    () =&gt; {
      document.title = title;
    });
}

// 使用:
function Home() {
	const title = '我是首页'
	useTitle(title)
	
	return (
		&lt;div&gt;{title}&lt;/div&gt;
	)
}
复制代码
</code></pre></div><h3 id="_7-ssr"><a href="#_7-ssr" class="header-anchor">#</a> 7. SSR</h3> <p>SSR，俗称 <strong>服务端渲染</strong> (Server Side Render)，讲人话就是: 直接在服务端层获取数据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。</p> <ul><li><strong>前后端分离</strong>: 前端与服务端隔离，前端动态获取数据，渲染页面。</li> <li><strong>痛点</strong>:
<ul><li><strong>首屏渲染性能瓶颈</strong>:
<ul><li>空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时间。在这段时间内，页面处于空白的状态。</li></ul></li> <li><strong>SEO 问题</strong>: 由于页面初始状态为空，因此爬虫无法获取页面中任何有效数据，因此对搜索引擎不友好。
<ul><li>虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜索引擎仍然是没有实现。</li></ul></li></ul></li></ul> <p>最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独立的开发模式，又要由服务端渲染，因此我们使用 React SSR。</p> <ul><li><strong>原理</strong>:
<ul><li>Node 服务: 让前后端运行同一套代码成为可能。</li> <li>Virtual Dom: 让前端代码脱离浏览器运行。</li></ul></li> <li><strong>条件</strong>: Node 中间层、 React / Vue 等框架。 结构大概如下:</li></ul> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/21/1699e0d41797a4d1~tplv-t2oaga2asx-watermark.awebp" alt="img"></p> <ul><li><p><strong>开发流程</strong>: (此处以 React + Router + Redux + Koa 为例)</p> <ul><li>1、在同个项目中，<strong>搭建</strong> 前后端部分，常规结构:
<ul><li>build</li> <li>public</li> <li>src
<ul><li>client</li> <li>server</li></ul></li></ul></li> <li>2、server 中使用 Koa <strong>路由监听</strong> 页面访问:</li></ul> <div class="language- extra-class"><pre class="language-text"><code>import * as Router from 'koa-router'

const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () =&gt; {
	// 返回数据
})

router.get('*', async (ctx) =&gt; {
	// 返回 HTML
})
复制代码
</code></pre></div><ul><li>3、通过访问 url <strong>匹配</strong> 前端页面路由:</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 前端页面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'

// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
</code></pre></div><ul><li><p>4、通过页面路由的配置进行 <strong>数据获取</strong>。通常可以在页面路由中增加 SSR 相关的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:</p> <div class="language- extra-class"><pre class="language-text"><code>class HomePage extends React.Component{
	public static ssrConfig = {
		  cache: true,
         fetch() {
        	  // 请求获取数据
         }
    }
}
复制代码
</code></pre></div><p>获取数据通常有两种情况:</p> <ul><li>中间层也使用 <strong>http</strong> 获取数据，则此时 fetch 方法可前后端共享；</li></ul> <div class="language- extra-class"><pre class="language-text"><code>const data = await matchPage.ssrConfig.fetch()
复制代码
</code></pre></div><ul><li>中间层并不使用 http，是通过一些 <strong>内部调用</strong>，例如 Rpc 或 直接读数据库 等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 页面路由
class HomePage extends React.Component{
	public static ssrConfig = {
        fetch: {
        	 url: '/api/home',
        }
    }
}

// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)

// 获取数据
const data = await controller(ctx)
复制代码
</code></pre></div></li> <li><p>5、创建 Redux store，并将数据<code>dispatch</code>到里面:</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'

// 创建 store
const store = createStore(reducers)
 
// 获取配置好的 Action
const action = ssrConfig.action

// 存储数据	
store.dispatch(createAction(action)(data))
复制代码
</code></pre></div><ul><li>6、注入 Store， 调用<code>renderToString</code>将 React Virtual Dom 渲染成 <strong>字符串</strong>:</li></ul> <div class="language- extra-class"><pre class="language-text"><code>import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'

// 获取 Clinet 层根组件
import { App } from '../../client/app'

const AppString = ReactDOMServer.renderToString(
	&lt;Provider store={store}&gt;
		&lt;StaticRouter
			location={ctx.req.url}
			context={{}}&gt;
			&lt;App /&gt;
		&lt;/StaticRouter&gt;
	&lt;/Provider&gt;
)
复制代码
</code></pre></div><ul><li>7、将 AppString 包装成完整的 html 文件格式；</li> <li>8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的页面，没有样式没有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成的<code>asset-manifest.json</code>文件来获取相应的文件路径，并同样注入到 Html 中引用。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>const html = `
	&lt;!DOCTYPE html&gt;
	&lt;html lang=&quot;zh&quot;&gt;
		&lt;head&gt;&lt;/head&gt;
		&lt;link href=&quot;${cssPath}&quot; rel=&quot;stylesheet&quot; /&gt;
		&lt;body&gt;
			&lt;div id=&quot;App&quot;&gt;${AppString}&lt;/div&gt;
			&lt;script src=&quot;${scriptPath}&quot;&gt;&lt;/script&gt;
		&lt;/body&gt;
	&lt;/html&gt;
`
复制代码
</code></pre></div><ul><li>9、进行 <strong>数据脱水</strong>: 为了把服务端获取的数据同步到前端。主要是将数据序列化后，插入到 html 中，返回给前端。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
	&lt;!DOCTYPE html&gt;
	&lt;html lang=&quot;zh&quot;&gt;
		&lt;head&gt;&lt;/head&gt;
		&lt;body&gt;
			&lt;div id=&quot;App&quot;&gt;&lt;/div&gt;
			&lt;script type=&quot;application/json&quot; id=&quot;SSR_HYDRATED_DATA&quot;&gt;${serialize(initState)}&lt;/script&gt;
		&lt;/body&gt;
	&lt;/html&gt;
`

ctx.status = 200
ctx.body = html
复制代码
</code></pre></div><blockquote><p><strong>Tips</strong>:</p> <p>这里比较特别的有两点:</p> <ol><li>使用了<code>serialize-javascript</code>序列化 store， 替代了<code>JSON.stringify</code>，保证数据的安全性，避免代码注入和 XSS 攻击；</li> <li>使用 json 进行传输，可以获得更快的加载速度；</li></ol></blockquote> <ul><li>10、Client 层 <strong>数据吸水</strong>: 初始化 store 时，以脱水后的数据为初始化数据，同步创建 store。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)

// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
</code></pre></div></li></ul> <h3 id="_8-函数式编程"><a href="#_8-函数式编程" class="header-anchor">#</a> 8. 函数式编程</h3> <p>函数式编程是一种 <strong>编程范式</strong>，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础与边界法则，追求的是 <strong>更简洁、可预测、高复用、易测试</strong>。其实在现有的众多知名库中，都蕴含着丰富的函数式编程思想，如 React / Redux 等。</p> <ul><li><p><strong>常见的编程范式</strong>:</p> <ul><li>命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做什么；</li> <li>事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；</li> <li>面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承性、多态性；</li> <li>函数式编程
<ul><li>换成一种更高端的说法，面向数学编程。怕不怕~🥴</li></ul></li></ul></li> <li><p><strong>函数式编程的理念</strong>:</p> <ul><li><p><strong>纯函数</strong>(确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维护；</p> <ul><li><strong>优势</strong>:
<ul><li>完全独立，与外部解耦；</li> <li>高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳定；</li> <li>可测试性极强；</li></ul></li> <li><strong>条件</strong>:
<ul><li>不修改参数；</li> <li>不依赖、不修改任何函数外部的数据；</li> <li>完全可控，参数一样，返回值一定一样: 例如函数不能包含<code>new Date()</code>或者<code>Math.rando()</code>等这种不可控因素；</li> <li>引用透明；</li></ul></li> <li>我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如<code>split / join / map</code>；</li></ul></li> <li><p><strong>函数复合</strong>: 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最后的目标；</p> <ul><li><p><strong>扁平化嵌套</strong>: 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在 JS 中，函数也可以当做参数:</p> <ul><li><code>f(g(k(x)))</code>: 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；</li> <li>理想的做法: <code>xxx(f, g, k)(x)</code></li></ul></li> <li><p><strong>结果传递</strong>: 如果想实现上面的方式，那也就是<code>xxx</code>函数要实现的便是: 执行结果在各个函数之间的执行传递；</p> <ul><li>这时我们就能想到一个原生提供的数组方法: <code>reduce</code>，它可以按数组的顺序依次执行，传递执行结果；</li> <li>所以我们就能够实现一个方法<code>pipe</code>，用于函数组合:</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) =&gt; p =&gt; fs.reduce((v, f) =&gt; f(v), p)
复制代码
</code></pre></div></li> <li><p><strong>使用</strong>: 实现一个 驼峰命名 转 中划线命名 的功能:</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 'Guo DongDong' --&gt; 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str =&gt; str.toLowerCase()
const join = curry((str, arr) =&gt; arr.join(str))
const split = curry((splitOn, str) =&gt; str.split(splitOn));

const toSlug = pipe(
	toLowerCase,	
	split(' '),
	join('_'),
	encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
</code></pre></div><ul><li><p><strong>好处</strong>:</p> <ul><li>隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；</li> <li>只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；</li> <li>可复用性强，任何一个函数单元都可被任意复用和组合；</li> <li>可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:</li></ul> <div class="language- extra-class"><pre class="language-text"><code>const log = curry((label, x) =&gt; {
	console.log(`${ label }: ${ x }`);
	return x;
});

const toSlug = pipe(
	toLowerCase,	
	log('toLowerCase output'),
	split(' '),
	log('split output'),
	join('_'),
	log('join output'),
	encodeURIComponent,
);
复制代码
</code></pre></div></li></ul> <blockquote><p>Tips:</p> <p>一些工具纯函数可直接引用<code>lodash/fp</code>，例如<code>curry/map/split</code>等，并不需要像我们上面这样自己实现；</p></blockquote></li> <li><p><strong>数据不可变性</strong>(immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:</p> <ul><li><p><strong>倡导</strong>: 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新的对象，而不是直接在原对象上修改；</p></li> <li><p><strong>目的</strong>: 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异常，能有效提高可控性与稳定性；</p></li> <li><p>并不等同于<code>const</code>。使用<code>const</code>创建一个对象后，它的属性仍然可以被修改；</p></li> <li><p>更类似于<code>Object.freeze</code>: 冻结对象，但<code>freeze</code>仍无法保证深层的属性不被串改；</p></li> <li><div class="language- extra-class"><pre class="language-text"><code>immutable.js
</code></pre></div><p>: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被广泛应用，大大提升了性能与稳定性；</p> <ul><li><div class="language- extra-class"><pre class="language-text"><code>trie
</code></pre></div><p>数据结构:</p> <ul><li>一种数据结构，能有效地深度冻结对象，保证其不可变；</li> <li><strong>结构共享</strong>: 可以共用不可变对象的内存引用地址，减少内存占用，提高数据操作性能；</li></ul></li></ul></li></ul></li> <li><p>避免不同函数之间的 <strong>状态共享</strong>，数据的传递使用复制或全新对象，遵守数据不可变原则；</p></li> <li><p>避免从函数内部 <strong>改变外部状态</strong>，例如改变了全局作用域或父级作用域上的变量值，可能会导致其它单位错误；</p></li> <li><p>避免在单元函数内部执行一些 <strong>副作用</strong>，应该将这些操作抽离成更独立的工具单元；</p> <ul><li>日志输出</li> <li>读写文件</li> <li>网络请求</li> <li>调用外部进程</li> <li>调用有副作用的函数</li></ul></li></ul></li> <li><p><strong>高阶函数</strong>: 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:</p> <ul><li>将逻辑行为进行 <strong>隔离抽象</strong>，便于快速复用，如处理数据，兼容性等；</li> <li><strong>函数组合</strong>，将一系列单元函数列表组合成功能更强大的函数；</li> <li><strong>函数增强</strong>，快速地拓展函数功能，</li></ul></li> <li><p><strong>函数式编程的好处</strong>:</p> <ul><li>函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；</li> <li>不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提高稳定性与健壮性；</li> <li>追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；</li> <li>更易于做单元测试。</li></ul></li> <li><p><strong>总结</strong>:</p> <ul><li>函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单元函数，组合调用操作数据流；</li> <li>它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部 / 副作用；</li></ul></li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">3/21/2022, 9:01:05 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/JavaScript/面试-js.html" class="prev">
        1、原型和原型链
      </a></span> <span class="next"><a href="/JavaScript/面试-服务器网络.html">
        /JavaScript/面试-服务器网络.html
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.b51e4ccd.js" defer></script><script src="/assets/js/2.7229199a.js" defer></script><script src="/assets/js/19.3d59a8e1.js" defer></script>
  </body>
</html>
