<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>英俊的大亨亨</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="heng.png">
    <meta name="description" content="记录下有趣岁月的点点滴滴">
    
    <link rel="preload" href="/assets/css/0.styles.e4d8b86b.css" as="style"><link rel="preload" href="/assets/js/app.b51e4ccd.js" as="script"><link rel="preload" href="/assets/js/2.7229199a.js" as="script"><link rel="preload" href="/assets/js/137.eb295fce.js" as="script"><link rel="prefetch" href="/assets/js/10.00f8a9d8.js"><link rel="prefetch" href="/assets/js/100.78dfd44a.js"><link rel="prefetch" href="/assets/js/101.cdae98a0.js"><link rel="prefetch" href="/assets/js/102.6a3dd9e0.js"><link rel="prefetch" href="/assets/js/103.cfed07a2.js"><link rel="prefetch" href="/assets/js/104.a16a4843.js"><link rel="prefetch" href="/assets/js/105.9cd1add0.js"><link rel="prefetch" href="/assets/js/106.546c1ad8.js"><link rel="prefetch" href="/assets/js/107.04b38bf9.js"><link rel="prefetch" href="/assets/js/108.31a22b61.js"><link rel="prefetch" href="/assets/js/109.1f2a1840.js"><link rel="prefetch" href="/assets/js/11.e2689dc6.js"><link rel="prefetch" href="/assets/js/110.9dc2f13b.js"><link rel="prefetch" href="/assets/js/111.35cf70f8.js"><link rel="prefetch" href="/assets/js/112.39a6579b.js"><link rel="prefetch" href="/assets/js/113.cbfc279d.js"><link rel="prefetch" href="/assets/js/114.878470a2.js"><link rel="prefetch" href="/assets/js/115.86dc4d8e.js"><link rel="prefetch" href="/assets/js/116.d2e05b2c.js"><link rel="prefetch" href="/assets/js/117.7525671d.js"><link rel="prefetch" href="/assets/js/118.a5c04c6d.js"><link rel="prefetch" href="/assets/js/119.613a81e1.js"><link rel="prefetch" href="/assets/js/12.0b7aaea4.js"><link rel="prefetch" href="/assets/js/120.ec6d3159.js"><link rel="prefetch" href="/assets/js/121.6705f783.js"><link rel="prefetch" href="/assets/js/122.7b3fe034.js"><link rel="prefetch" href="/assets/js/123.9336f454.js"><link rel="prefetch" href="/assets/js/124.dca9fc87.js"><link rel="prefetch" href="/assets/js/125.338aa4d8.js"><link rel="prefetch" href="/assets/js/126.a731a9eb.js"><link rel="prefetch" href="/assets/js/127.da74dd90.js"><link rel="prefetch" href="/assets/js/128.3d5e86f2.js"><link rel="prefetch" href="/assets/js/129.ee43b65c.js"><link rel="prefetch" href="/assets/js/13.31064a46.js"><link rel="prefetch" href="/assets/js/130.8a273d75.js"><link rel="prefetch" href="/assets/js/131.a89df4ac.js"><link rel="prefetch" href="/assets/js/132.0daac28c.js"><link rel="prefetch" href="/assets/js/133.b1f23c92.js"><link rel="prefetch" href="/assets/js/134.78621a9c.js"><link rel="prefetch" href="/assets/js/135.f0884a8b.js"><link rel="prefetch" href="/assets/js/136.45114430.js"><link rel="prefetch" href="/assets/js/138.cc7dc8d3.js"><link rel="prefetch" href="/assets/js/139.c9b1aad6.js"><link rel="prefetch" href="/assets/js/14.0be4ee49.js"><link rel="prefetch" href="/assets/js/15.685fab30.js"><link rel="prefetch" href="/assets/js/16.97f8b16a.js"><link rel="prefetch" href="/assets/js/17.9c7bebeb.js"><link rel="prefetch" href="/assets/js/18.965d9e47.js"><link rel="prefetch" href="/assets/js/19.3d59a8e1.js"><link rel="prefetch" href="/assets/js/20.1573d510.js"><link rel="prefetch" href="/assets/js/21.f46234dd.js"><link rel="prefetch" href="/assets/js/22.6c16fd38.js"><link rel="prefetch" href="/assets/js/23.50a2a38a.js"><link rel="prefetch" href="/assets/js/24.8aff8273.js"><link rel="prefetch" href="/assets/js/25.35a7c496.js"><link rel="prefetch" href="/assets/js/26.af233874.js"><link rel="prefetch" href="/assets/js/27.a3a96a5a.js"><link rel="prefetch" href="/assets/js/28.a1d49602.js"><link rel="prefetch" href="/assets/js/29.174b7d7d.js"><link rel="prefetch" href="/assets/js/3.6038f64c.js"><link rel="prefetch" href="/assets/js/30.a4115d32.js"><link rel="prefetch" href="/assets/js/31.1522875a.js"><link rel="prefetch" href="/assets/js/32.35da527d.js"><link rel="prefetch" href="/assets/js/33.814d63e8.js"><link rel="prefetch" href="/assets/js/34.615b49c1.js"><link rel="prefetch" href="/assets/js/35.856ab789.js"><link rel="prefetch" href="/assets/js/36.2987bc62.js"><link rel="prefetch" href="/assets/js/37.084d12aa.js"><link rel="prefetch" href="/assets/js/38.088f3091.js"><link rel="prefetch" href="/assets/js/39.4ea066d5.js"><link rel="prefetch" href="/assets/js/4.c610d016.js"><link rel="prefetch" href="/assets/js/40.97850ba9.js"><link rel="prefetch" href="/assets/js/41.8b8ae086.js"><link rel="prefetch" href="/assets/js/42.8ae2cac3.js"><link rel="prefetch" href="/assets/js/43.f8a28187.js"><link rel="prefetch" href="/assets/js/44.5160f68a.js"><link rel="prefetch" href="/assets/js/45.6d4b7130.js"><link rel="prefetch" href="/assets/js/46.44693348.js"><link rel="prefetch" href="/assets/js/47.eb0ac18a.js"><link rel="prefetch" href="/assets/js/48.ce1c6335.js"><link rel="prefetch" href="/assets/js/49.7ec1b16a.js"><link rel="prefetch" href="/assets/js/5.216dfe20.js"><link rel="prefetch" href="/assets/js/50.1f503aa4.js"><link rel="prefetch" href="/assets/js/51.47971163.js"><link rel="prefetch" href="/assets/js/52.e5f681d7.js"><link rel="prefetch" href="/assets/js/53.df89fbb7.js"><link rel="prefetch" href="/assets/js/54.a140a8dd.js"><link rel="prefetch" href="/assets/js/55.5809711e.js"><link rel="prefetch" href="/assets/js/56.3a62759d.js"><link rel="prefetch" href="/assets/js/57.c9bd4339.js"><link rel="prefetch" href="/assets/js/58.acb475d1.js"><link rel="prefetch" href="/assets/js/59.61cf3322.js"><link rel="prefetch" href="/assets/js/6.73a8f323.js"><link rel="prefetch" href="/assets/js/60.aa39146e.js"><link rel="prefetch" href="/assets/js/61.f62972b8.js"><link rel="prefetch" href="/assets/js/62.79fc1ddc.js"><link rel="prefetch" href="/assets/js/63.808c750c.js"><link rel="prefetch" href="/assets/js/64.4e99e2e1.js"><link rel="prefetch" href="/assets/js/65.f112caec.js"><link rel="prefetch" href="/assets/js/66.422cc6c9.js"><link rel="prefetch" href="/assets/js/67.f504a803.js"><link rel="prefetch" href="/assets/js/68.f8e84a65.js"><link rel="prefetch" href="/assets/js/69.af07ae00.js"><link rel="prefetch" href="/assets/js/7.a6e60d89.js"><link rel="prefetch" href="/assets/js/70.9b212396.js"><link rel="prefetch" href="/assets/js/71.049b7d3e.js"><link rel="prefetch" href="/assets/js/72.b508f834.js"><link rel="prefetch" href="/assets/js/73.52a25a21.js"><link rel="prefetch" href="/assets/js/74.68de4c01.js"><link rel="prefetch" href="/assets/js/75.c0d8e99a.js"><link rel="prefetch" href="/assets/js/76.672b246e.js"><link rel="prefetch" href="/assets/js/77.36d886e3.js"><link rel="prefetch" href="/assets/js/78.079ebfd8.js"><link rel="prefetch" href="/assets/js/79.d3d3e8ea.js"><link rel="prefetch" href="/assets/js/8.a72c567f.js"><link rel="prefetch" href="/assets/js/80.c690c3d9.js"><link rel="prefetch" href="/assets/js/81.c012b7d5.js"><link rel="prefetch" href="/assets/js/82.47ffa460.js"><link rel="prefetch" href="/assets/js/83.2ba84114.js"><link rel="prefetch" href="/assets/js/84.dc0bf5a8.js"><link rel="prefetch" href="/assets/js/85.d968ae8b.js"><link rel="prefetch" href="/assets/js/86.91000a3b.js"><link rel="prefetch" href="/assets/js/87.6e885c71.js"><link rel="prefetch" href="/assets/js/88.99dd2b79.js"><link rel="prefetch" href="/assets/js/89.601c57ea.js"><link rel="prefetch" href="/assets/js/9.c59ba06b.js"><link rel="prefetch" href="/assets/js/90.89ee0da5.js"><link rel="prefetch" href="/assets/js/91.854de449.js"><link rel="prefetch" href="/assets/js/92.7a25d006.js"><link rel="prefetch" href="/assets/js/93.17f89281.js"><link rel="prefetch" href="/assets/js/94.0f6749b9.js"><link rel="prefetch" href="/assets/js/95.41ef6f4a.js"><link rel="prefetch" href="/assets/js/96.12427920.js"><link rel="prefetch" href="/assets/js/97.53036963.js"><link rel="prefetch" href="/assets/js/98.43d8f870.js"><link rel="prefetch" href="/assets/js/99.4ab32fce.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e4d8b86b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/heng.png" alt="英俊的大亨亨" class="logo"> <span class="site-name can-hide">英俊的大亨亨</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">js</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">js</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/js/js-基础.html" class="nav-link">
  基础
</a></li><li class="dropdown-item"><!----> <a href="/js/js-数组.html" class="nav-link">
  数组
</a></li><li class="dropdown-item"><!----> <a href="/js/js-异步.html" class="nav-link">
  异步
</a></li><li class="dropdown-item"><!----> <a href="/js/js-es6.html" class="nav-link">
  es6
</a></li><li class="dropdown-item"><!----> <a href="/js/js-v8引擎.html" class="nav-link">
  v8
</a></li><li class="dropdown-item"><!----> <a href="/手写代码/1.js基础.html" class="nav-link">
  手写
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">前端基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">前端基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          前端基础
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/react/process.html" class="nav-link">
  
</a></li></ul></li><li class="dropdown-item"><!----> <a href="/html.html" class="nav-link">
  html
</a></li><li class="dropdown-item"><!----> <a href="/css.html" class="nav-link">
  css
</a></li><li class="dropdown-item"><!----> <a href="/node.html" class="nav-link">
  node
</a></li><li class="dropdown-item"><!----> <a href="/webpack.html" class="nav-link">
  webpack
</a></li><li class="dropdown-item"><!----> <a href="/webpack.html" class="nav-link">
  小程序
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="leetcode" class="dropdown-title"><span class="title">leetcode</span> <span class="arrow down"></span></button> <button type="button" aria-label="leetcode" class="mobile-dropdown-title"><span class="title">leetcode</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/代码随想录/1.数组.html" class="nav-link">
  1.数组
</a></li><li class="dropdown-item"><!----> <a href="/代码随想录/10.动态规划/1.基础.html" class="nav-link">
  10.动态规划
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">react源码</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">react源码</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/react源码/理念.html" class="nav-link">
  1.理念
</a></li><li class="dropdown-item"><!----> <a href="/react源码/3.render.html" class="nav-link">
  3.render
</a></li><li class="dropdown-item"><!----> <a href="/react源码/4.commit.html" class="nav-link">
  4.commit
</a></li><li class="dropdown-item"><!----> <a href="/react源码/5.状态更新.html" class="nav-link">
  5.状态更新
</a></li><li class="dropdown-item"><!----> <a href="/react源码/6.diff.html" class="nav-link">
  6.diff
</a></li><li class="dropdown-item"><!----> <a href="/react/7.实现hooks.html" class="nav-link">
  7.实现hooks
</a></li><li class="dropdown-item"><!----> <a href="/react/8.concurrentMode.html" class="nav-link">
  8.concurrentMode
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">webpack</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">webpack</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/webpack/1.配置.html" class="nav-link">
  1.配置
</a></li><li class="dropdown-item"><!----> <a href="/webpack/2.loader.html" class="nav-link">
  2.loader
</a></li><li class="dropdown-item"><!----> <a href="/webpack/3.plugin.html" class="nav-link">
  3.plugin
</a></li><li class="dropdown-item"><!----> <a href="/webpack/4.模块化原理.html" class="nav-link">
  4.模块化原理
</a></li><li class="dropdown-item"><!----> <a href="/webpack/5.babel.html" class="nav-link">
  5.babel
</a></li><li class="dropdown-item"><!----> <a href="/webpack/6.HMR.html" class="nav-link">
  6.HMR
</a></li><li class="dropdown-item"><!----> <a href="/webpack/7.环境分离.html" class="nav-link">
  7.环境分离
</a></li><li class="dropdown-item"><!----> <a href="/webpack/8.tree_shaking.html" class="nav-link">
  8.tree_shaking
</a></li><li class="dropdown-item"><!----> <a href="/webpack/9,源码.html" class="nav-link">
  9.源码
</a></li><li class="dropdown-item"><!----> <a href="/webpack/11.自定义loader.html" class="nav-link">
  11.自定义loader
</a></li><li class="dropdown-item"><!----> <a href="/webpack/12.自定义plugin.html" class="nav-link">
  12.自定义plugin
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">前端设计模式</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">前端设计模式</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/设计模式/创建型.html" class="nav-link">
  创建型
</a></li><li class="dropdown-item"><!----> <a href="/设计模式/结构型.html" class="nav-link">
  结构型
</a></li><li class="dropdown-item"><!----> <a href="/设计模式/行为型.html" class="nav-link">
  行为型
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">angular</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">angular</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/.html" class="nav-link">
  angular性能调优
</a></li><li class="dropdown-item"><!----> <a href="/设计模式/结构型.html" class="nav-link">
  angular源码理解
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">健身</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">健身</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/.html" class="nav-link">
  angular性能调优
</a></li><li class="dropdown-item"><!----> <a href="/设计模式/结构型.html" class="nav-link">
  angular源码理解
</a></li></ul></div></div><div class="nav-item"><a href="/me.html" class="nav-link">
  关于我
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">js</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">js</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/js/js-基础.html" class="nav-link">
  基础
</a></li><li class="dropdown-item"><!----> <a href="/js/js-数组.html" class="nav-link">
  数组
</a></li><li class="dropdown-item"><!----> <a href="/js/js-异步.html" class="nav-link">
  异步
</a></li><li class="dropdown-item"><!----> <a href="/js/js-es6.html" class="nav-link">
  es6
</a></li><li class="dropdown-item"><!----> <a href="/js/js-v8引擎.html" class="nav-link">
  v8
</a></li><li class="dropdown-item"><!----> <a href="/手写代码/1.js基础.html" class="nav-link">
  手写
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">前端基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">前端基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          前端基础
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/react/process.html" class="nav-link">
  
</a></li></ul></li><li class="dropdown-item"><!----> <a href="/html.html" class="nav-link">
  html
</a></li><li class="dropdown-item"><!----> <a href="/css.html" class="nav-link">
  css
</a></li><li class="dropdown-item"><!----> <a href="/node.html" class="nav-link">
  node
</a></li><li class="dropdown-item"><!----> <a href="/webpack.html" class="nav-link">
  webpack
</a></li><li class="dropdown-item"><!----> <a href="/webpack.html" class="nav-link">
  小程序
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="leetcode" class="dropdown-title"><span class="title">leetcode</span> <span class="arrow down"></span></button> <button type="button" aria-label="leetcode" class="mobile-dropdown-title"><span class="title">leetcode</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/代码随想录/1.数组.html" class="nav-link">
  1.数组
</a></li><li class="dropdown-item"><!----> <a href="/代码随想录/10.动态规划/1.基础.html" class="nav-link">
  10.动态规划
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">react源码</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">react源码</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/react源码/理念.html" class="nav-link">
  1.理念
</a></li><li class="dropdown-item"><!----> <a href="/react源码/3.render.html" class="nav-link">
  3.render
</a></li><li class="dropdown-item"><!----> <a href="/react源码/4.commit.html" class="nav-link">
  4.commit
</a></li><li class="dropdown-item"><!----> <a href="/react源码/5.状态更新.html" class="nav-link">
  5.状态更新
</a></li><li class="dropdown-item"><!----> <a href="/react源码/6.diff.html" class="nav-link">
  6.diff
</a></li><li class="dropdown-item"><!----> <a href="/react/7.实现hooks.html" class="nav-link">
  7.实现hooks
</a></li><li class="dropdown-item"><!----> <a href="/react/8.concurrentMode.html" class="nav-link">
  8.concurrentMode
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">webpack</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">webpack</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/webpack/1.配置.html" class="nav-link">
  1.配置
</a></li><li class="dropdown-item"><!----> <a href="/webpack/2.loader.html" class="nav-link">
  2.loader
</a></li><li class="dropdown-item"><!----> <a href="/webpack/3.plugin.html" class="nav-link">
  3.plugin
</a></li><li class="dropdown-item"><!----> <a href="/webpack/4.模块化原理.html" class="nav-link">
  4.模块化原理
</a></li><li class="dropdown-item"><!----> <a href="/webpack/5.babel.html" class="nav-link">
  5.babel
</a></li><li class="dropdown-item"><!----> <a href="/webpack/6.HMR.html" class="nav-link">
  6.HMR
</a></li><li class="dropdown-item"><!----> <a href="/webpack/7.环境分离.html" class="nav-link">
  7.环境分离
</a></li><li class="dropdown-item"><!----> <a href="/webpack/8.tree_shaking.html" class="nav-link">
  8.tree_shaking
</a></li><li class="dropdown-item"><!----> <a href="/webpack/9,源码.html" class="nav-link">
  9.源码
</a></li><li class="dropdown-item"><!----> <a href="/webpack/11.自定义loader.html" class="nav-link">
  11.自定义loader
</a></li><li class="dropdown-item"><!----> <a href="/webpack/12.自定义plugin.html" class="nav-link">
  12.自定义plugin
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">前端设计模式</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">前端设计模式</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/设计模式/创建型.html" class="nav-link">
  创建型
</a></li><li class="dropdown-item"><!----> <a href="/设计模式/结构型.html" class="nav-link">
  结构型
</a></li><li class="dropdown-item"><!----> <a href="/设计模式/行为型.html" class="nav-link">
  行为型
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">angular</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">angular</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/.html" class="nav-link">
  angular性能调优
</a></li><li class="dropdown-item"><!----> <a href="/设计模式/结构型.html" class="nav-link">
  angular源码理解
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">健身</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">健身</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/.html" class="nav-link">
  angular性能调优
</a></li><li class="dropdown-item"><!----> <a href="/设计模式/结构型.html" class="nav-link">
  angular源码理解
</a></li></ul></div></div><div class="nav-item"><a href="/me.html" class="nav-link">
  关于我
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>设计模式</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/设计模式/1.创建型.html" class="active sidebar-link">/设计模式/1.创建型.html</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/设计模式/1.创建型.html#简单工厂模式" class="sidebar-link">简单工厂模式</a></li><li class="sidebar-sub-header"><a href="/设计模式/1.创建型.html#小结" class="sidebar-link">小结</a></li><li class="sidebar-sub-header"><a href="/设计模式/1.创建型.html#一个不简单的简单工厂引发的命案" class="sidebar-link">一个不简单的简单工厂引发的命案</a></li><li class="sidebar-sub-header"><a href="/设计模式/1.创建型.html#抽象工厂模式" class="sidebar-link">抽象工厂模式</a></li><li class="sidebar-sub-header"><a href="/设计模式/1.创建型.html#总结" class="sidebar-link">总结</a></li><li class="sidebar-sub-header"><a href="/设计模式/1.创建型.html#最后-再跟大家谈谈学习" class="sidebar-link">最后，再跟大家谈谈学习</a></li><li class="sidebar-sub-header"><a href="/设计模式/1.创建型.html#单例模式的实现思路" class="sidebar-link">单例模式的实现思路</a></li><li class="sidebar-sub-header"><a href="/设计模式/1.创建型.html#生产实践-vuex中的单例模式" class="sidebar-link">生产实践：Vuex中的单例模式</a></li><li class="sidebar-sub-header"><a href="/设计模式/1.创建型.html#小结-2" class="sidebar-link">小结</a></li><li class="sidebar-sub-header"><a href="/设计模式/1.创建型.html#实现一个-storage" class="sidebar-link">实现一个 Storage</a></li><li class="sidebar-sub-header"><a href="/设计模式/1.创建型.html#实现一个全局的模态框" class="sidebar-link">实现一个全局的模态框</a></li><li class="sidebar-sub-header"><a href="/设计模式/1.创建型.html#以类为中心的语言和以原型为中心的语言" class="sidebar-link">以类为中心的语言和以原型为中心的语言</a></li><li class="sidebar-sub-header"><a href="/设计模式/1.创建型.html#谈原型模式-其实是谈原型范式" class="sidebar-link">谈原型模式，其实是谈原型范式</a></li></ul></li><li><a href="/设计模式/2.结构型.html" class="sidebar-link">/设计模式/2.结构型.html</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/设计模式/2.结构型.html#生活中的装饰器" class="sidebar-link">生活中的装饰器</a></li><li class="sidebar-sub-header"><a href="/设计模式/2.结构型.html#装饰器的应用场景" class="sidebar-link">装饰器的应用场景</a></li><li class="sidebar-sub-header"><a href="/设计模式/2.结构型.html#装饰器模式初相见" class="sidebar-link">装饰器模式初相见</a></li><li class="sidebar-sub-header"><a href="/设计模式/2.结构型.html#值得关注的细节" class="sidebar-link">值得关注的细节</a></li><li class="sidebar-sub-header"><a href="/设计模式/2.结构型.html#前置知识-es7-中的装饰器" class="sidebar-link">前置知识：ES7 中的装饰器</a></li><li class="sidebar-sub-header"><a href="/设计模式/2.结构型.html#装饰器语法糖背后的故事" class="sidebar-link">装饰器语法糖背后的故事</a></li><li class="sidebar-sub-header"><a href="/设计模式/2.结构型.html#生产实践" class="sidebar-link">生产实践</a></li><li class="sidebar-sub-header"><a href="/设计模式/2.结构型.html#生活中的适配器" class="sidebar-link">生活中的适配器</a></li><li class="sidebar-sub-header"><a href="/设计模式/2.结构型.html#兼容接口就是一把梭-适配器的业务场景" class="sidebar-link">兼容接口就是一把梭——适配器的业务场景</a></li><li class="sidebar-sub-header"><a href="/设计模式/2.结构型.html#生产实践-axios中的适配器" class="sidebar-link">生产实践：axios中的适配器</a></li><li class="sidebar-sub-header"><a href="/设计模式/2.结构型.html#小结" class="sidebar-link">小结</a></li><li class="sidebar-sub-header"><a href="/设计模式/2.结构型.html#科学上网背后的故事" class="sidebar-link">科学上网背后的故事</a></li><li class="sidebar-sub-header"><a href="/设计模式/2.结构型.html#婚姻介绍所的故事" class="sidebar-link">婚姻介绍所的故事</a></li><li class="sidebar-sub-header"><a href="/设计模式/2.结构型.html#用代理模式开一家婚姻介绍所吧" class="sidebar-link">用代理模式开一家婚姻介绍所吧</a></li><li class="sidebar-sub-header"><a href="/设计模式/2.结构型.html#事件代理" class="sidebar-link">事件代理</a></li><li class="sidebar-sub-header"><a href="/设计模式/2.结构型.html#虚拟代理" class="sidebar-link">虚拟代理</a></li><li class="sidebar-sub-header"><a href="/设计模式/2.结构型.html#缓存代理" class="sidebar-link">缓存代理</a></li><li class="sidebar-sub-header"><a href="/设计模式/2.结构型.html#保护代理" class="sidebar-link">保护代理</a></li><li class="sidebar-sub-header"><a href="/设计模式/2.结构型.html#小结-2" class="sidebar-link">小结</a></li></ul></li><li><a href="/设计模式/3.行为型.html" class="sidebar-link">/设计模式/3.行为型.html</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/设计模式/3.行为型.html#先来看一个真实场景" class="sidebar-link">先来看一个真实场景</a></li><li class="sidebar-sub-header"><a href="/设计模式/3.行为型.html#if-else-侠-人人喊打" class="sidebar-link">if-else 侠，人人喊打</a></li><li class="sidebar-sub-header"><a href="/设计模式/3.行为型.html#重构询价逻辑" class="sidebar-link">重构询价逻辑</a></li><li class="sidebar-sub-header"><a href="/设计模式/3.行为型.html#这-就是策略模式" class="sidebar-link">这，就是策略模式！</a></li><li class="sidebar-sub-header"><a href="/设计模式/3.行为型.html#咖啡奇缘一杯咖啡带来的思考" class="sidebar-link">~~咖啡奇缘~~一杯咖啡带来的思考</a></li><li class="sidebar-sub-header"><a href="/设计模式/3.行为型.html#一台咖啡机的诞生" class="sidebar-link">一台咖啡机的诞生</a></li><li class="sidebar-sub-header"><a href="/设计模式/3.行为型.html#不-我李雷必不可能再做-if-else-侠" class="sidebar-link">不，我李雷必不可能再做 if-else 侠</a></li><li class="sidebar-sub-header"><a href="/设计模式/3.行为型.html#改造咖啡机的状态切换机制" class="sidebar-link">改造咖啡机的状态切换机制</a></li><li class="sidebar-sub-header"><a href="/设计模式/3.行为型.html#状态模式复盘" class="sidebar-link">状态模式复盘</a></li><li class="sidebar-sub-header"><a href="/设计模式/3.行为型.html#尾声" class="sidebar-link">尾声</a></li><li class="sidebar-sub-header"><a href="/设计模式/3.行为型.html#生活中的观察者模式" class="sidebar-link">生活中的观察者模式</a></li><li class="sidebar-sub-header"><a href="/设计模式/3.行为型.html#在实践中理解定义" class="sidebar-link">在实践中理解定义</a></li><li class="sidebar-sub-header"><a href="/设计模式/3.行为型.html#vue数据双向绑定-响应式系统-的实现原理" class="sidebar-link">Vue数据双向绑定（响应式系统）的实现原理</a></li><li class="sidebar-sub-header"><a href="/设计模式/3.行为型.html#实现一个event-bus-event-emitter" class="sidebar-link">实现一个Event Bus/ Event Emitter</a></li><li class="sidebar-sub-header"><a href="/设计模式/3.行为型.html#观察者模式与发布-订阅模式的区别是什么" class="sidebar-link">观察者模式与发布-订阅模式的区别是什么？</a></li><li class="sidebar-sub-header"><a href="/设计模式/3.行为型.html#公元前-的迭代器模式" class="sidebar-link">“公元前”的迭代器模式</a></li><li class="sidebar-sub-header"><a href="/设计模式/3.行为型.html#es6对迭代器的实现" class="sidebar-link">ES6对迭代器的实现</a></li><li class="sidebar-sub-header"><a href="/设计模式/3.行为型.html#一起实现一个迭代器生成函数吧" class="sidebar-link">一起实现一个迭代器生成函数吧!</a></li><li class="sidebar-sub-header"><a href="/设计模式/3.行为型.html#小结" class="sidebar-link">小结</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>简单工厂</p> <p>在介绍工厂模式之前，为了辅助大家的理解，我想先在这儿给大家介绍一下构造器模式。</p> <p>别看这个名字很吓人（其实设计模式里每个名字好像都挺吓人的哈哈哈），这玩意儿你几乎天天用（所以咱们不单独给它开小节），不信你来看看：</p> <p>有一天你写了个公司员工信息录入系统，这个系统开发阶段用户只有你自己，想怎么玩怎么玩。于是在创建“自己”这个唯一的用户的时候，你可以这么写：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> liLei <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">'李雷'</span><span class="token punctuation">,</span>
    age<span class="token operator">:</span> <span class="token number">25</span><span class="token punctuation">,</span>
    career<span class="token operator">:</span> <span class="token string">'coder'</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><p>有一天你的同桌韩梅梅突然说：“李雷，让我瞅瞅你的系统做得咋样了，我也想被录进去”。你说好，不就多一个人的事情吗，于是代码里手动多了一个韩梅梅：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> liLei <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">'李雷'</span><span class="token punctuation">,</span>
    age<span class="token operator">:</span> <span class="token number">25</span><span class="token punctuation">,</span>
    career<span class="token operator">:</span> <span class="token string">'coder'</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> hanMeiMei <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">'韩梅梅'</span><span class="token punctuation">,</span>
    age<span class="token operator">:</span> <span class="token number">24</span><span class="token punctuation">,</span>
    career<span class="token operator">:</span> <span class="token string">'product manager'</span>
<span class="token punctuation">}</span>
</code></pre></div><p>又过了两天你老板过来了，说李雷，系统今天提测了，先把部门的 500 人录入看看功能。李雷心想，500 个对象字面量，要死要死，还好我有<strong>构造函数</strong>。于是李雷写出了一个可以自动创建用户的 User 函数：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token parameter">name <span class="token punctuation">,</span> age<span class="token punctuation">,</span> career</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age
    <span class="token keyword">this</span><span class="token punctuation">.</span>career <span class="token operator">=</span> career 
<span class="token punctuation">}</span>
</code></pre></div><p>楼上个这 User，就是一个<strong>构造器</strong>。此处我们采用了 ES5 构造函数的写法，因为 ES6 中的 class 其实本质上还是函数，class 语法只是语法糖，构造函数，才是它的真面目。</p> <p>接下来要做的事情，就是让程序自动地去读取数据库里面一行行的员工信息，然后把拿到的姓名、年龄等字段塞进User函数里，进行一个简单的调用：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> career<span class="token punctuation">)</span>
</code></pre></div><p>从此李雷再也不用手写字面量。</p> <p>像 User 这样当新建对象的内存被分配后，用来初始化该对象的特殊函数，就叫做构造器。在 JavaScript 中，我们使用构造函数去初始化对象，就是应用了<strong>构造器模式</strong>。这个模式太简单了，简单到我这一通讲对很多同学来说其实并不必要，大家都是学过 JavaScript 基础的人，都知道怎么 new 一个对象。但是我们洋洋洒洒这么一段的目的，并不是为了带大家复习构造函数本身的用法，而是希望大家去思考开篇我们提到的问题：</p> <p><strong>在创建一个user过程中，谁变了，谁不变？</strong></p> <p>很明显，变的是每个user的姓名、年龄、工种这些值，这是用户的<strong>个性</strong>，不变的是每个员工都具备姓名、年龄、工种这些属性，这是用户的<strong>共性</strong>。</p> <p><strong>那么构造器做了什么？</strong></p> <p>构造器是不是将 name、age、career 赋值给对象的过程封装，确保了每个对象都具备这些属性，确保了<strong>共性</strong>的不变，同时将 name、age、career 各自的取值操作开放，确保了<strong>个性</strong>的灵活？</p> <p>如果在使用构造器模式的时候，我们本质上是去抽象了每个对象实例的变与不变。那么使用工厂模式时，我们要做的就是去抽象不同构造函数（类）之间的变与不变。</p> <h2 id="简单工厂模式"><a href="#简单工厂模式" class="header-anchor">#</a> 简单工厂模式</h2> <p>咱们先不说简单工厂模式定义是啥，咱们先来看李雷的新需求：</p> <p>老板说这个系统录入的信息也太简单了，程序员和产品经理之间的区别一个简单的<code>career</code>字段怎么能说得清？我要求这个系统具备<strong>给不同工种分配职责说明</strong>的功能。也就是说，要给每个工种的用户加上一个个性化的字段，来描述他们的工作内容。</p> <p>完了，这下员工的共性被拆离了。还好有构造器，李雷心想不就是多写个构造器的事儿吗，我写：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Coder</span><span class="token punctuation">(</span><span class="token parameter">name <span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age
    <span class="token keyword">this</span><span class="token punctuation">.</span>career <span class="token operator">=</span> <span class="token string">'coder'</span> 
    <span class="token keyword">this</span><span class="token punctuation">.</span>work <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'写代码'</span><span class="token punctuation">,</span><span class="token string">'写系分'</span><span class="token punctuation">,</span> <span class="token string">'修Bug'</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">ProductManager</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name 
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age
    <span class="token keyword">this</span><span class="token punctuation">.</span>career <span class="token operator">=</span> <span class="token string">'product manager'</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>work <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'订会议室'</span><span class="token punctuation">,</span> <span class="token string">'写PRD'</span><span class="token punctuation">,</span> <span class="token string">'催更'</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>现在我们有两个类（后面可能还会有更多的类），麻烦的事情来了：难道我每从数据库拿到一条数据，都要人工判断一下这个员工的工种，然后手动给它分配构造器吗？不行，这也是一个“变”，我们把这个“变”交给一个函数去处理：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Factory</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> career</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">switch</span><span class="token punctuation">(</span>career<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token string">'coder'</span><span class="token operator">:</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Coder</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span> 
            <span class="token keyword">break</span>
        <span class="token keyword">case</span> <span class="token string">'product manager'</span><span class="token operator">:</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ProductManager</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span>
            <span class="token keyword">break</span>
        <span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>看起来是好一些了，至少我们不用操心构造函数的分配问题了。但是大家注意我在 switch 的末尾写了个省略号，这个省略号比较恐怖。看着这个省略号，李雷哭了，他想到：整个公司上下有数十个工种，难道我要手写数十个类、数十行 switch 吗？</p> <p>当然不！回到我们最初的问题：大家仔细想想，在楼上这两段并不那么好的代码里，<strong>变的是什么？不变的又是什么？</strong></p> <p>Coder 和 ProductManager 两个工种的员工，是不是仍然存在都拥有 name、age、career、work 这四个属性这样的共性？它们之间的区别，在于每个字段取值的不同，以及 work 字段需要随 career 字段取值的不同而改变。这样一来，我们是不是对共性封装得不够彻底？那么相应地，共性与个性是不是分离得也不够彻底？
现在我们把相同的逻辑封装回User类里，然后把这个承载了共性的 User 类和个性化的逻辑判断写入同一个函数：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token parameter">name <span class="token punctuation">,</span> age<span class="token punctuation">,</span> career<span class="token punctuation">,</span> work</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age
    <span class="token keyword">this</span><span class="token punctuation">.</span>career <span class="token operator">=</span> career 
    <span class="token keyword">this</span><span class="token punctuation">.</span>work <span class="token operator">=</span> work
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">Factory</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> career</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> work
    <span class="token keyword">switch</span><span class="token punctuation">(</span>career<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token string">'coder'</span><span class="token operator">:</span>
            work <span class="token operator">=</span>  <span class="token punctuation">[</span><span class="token string">'写代码'</span><span class="token punctuation">,</span><span class="token string">'写系分'</span><span class="token punctuation">,</span> <span class="token string">'修Bug'</span><span class="token punctuation">]</span> 
            <span class="token keyword">break</span>
        <span class="token keyword">case</span> <span class="token string">'product manager'</span><span class="token operator">:</span>
            work <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'订会议室'</span><span class="token punctuation">,</span> <span class="token string">'写PRD'</span><span class="token punctuation">,</span> <span class="token string">'催更'</span><span class="token punctuation">]</span>
            <span class="token keyword">break</span>
        <span class="token keyword">case</span> <span class="token string">'boss'</span><span class="token operator">:</span>
            work <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'喝茶'</span><span class="token punctuation">,</span> <span class="token string">'看报'</span><span class="token punctuation">,</span> <span class="token string">'见客户'</span><span class="token punctuation">]</span>
        <span class="token keyword">case</span> <span class="token string">'xxx'</span><span class="token operator">:</span>
            <span class="token comment">// 其它工种的职责分配</span>
            <span class="token operator">...</span>
            
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> career<span class="token punctuation">,</span> work<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样一来，我们要做事情是不是简单太多了？不用自己时刻想着我拿到的这组数据是什么工种、我应该怎么给它分配构造函数，更不用手写无数个构造函数——Factory已经帮我们做完了一切，而我们只需要像以前一样<strong>无脑传参</strong>就可以了！</p> <p>现在我们一起来总结一下什么是工厂模式：工厂模式其实就是<strong>将创建对象的过程单独封装</strong>。它很像我们去餐馆点菜：比如说点一份西红柿炒蛋，我们不用关心西红柿怎么切、怎么打鸡蛋这些菜品制作过程中的问题，我们只关心摆上桌那道菜。在工厂模式里，我传参这个过程就是点菜，工厂函数里面运转的逻辑就相当于炒菜的厨师和上桌的服务员做掉的那部分工作——这部分工作我们同样不用关心，我们只要能拿到工厂交付给我们的实例结果就行了。</p> <p>总结一下：工厂模式的目的，就是为了实现<strong>无脑传参</strong>，就是为了爽！</p> <h2 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h2> <p>工厂模式的简单之处，在于它的概念相对好理解：将创建对象的过程单独封装，这样的操作就是工厂模式。同时它的应用场景也非常容易识别：有构造函数的地方，我们就应该想到简单工厂；在写了大量构造函数、调用了大量的 new、自觉非常不爽的情况下，我们就应该思考是不是可以掏出工厂模式重构我们的代码了。</p> <p>但工厂模式可不止这一种表达形式。本节我们可以看到，构造器解决的是多个对象实例的问题，简单工厂解决的是多个类的问题。那么当复杂度从多个类共存上升到多个工厂共存时又该怎么处理呢？在下个小节，我们一起来看看这个问题。</p> <p>抽象工厂</p> <p>抽象工厂这块知识，对入行以来一直写纯 JavaScript 的同学可能不太友好——因为抽象工厂在很长一段时间里，都被认为是 Java/C++ 这类语言的专利。</p> <p>Java/C++ 的特性是什么？它们是<strong>强类型的静态语言</strong>。用这些语言创建对象时，我们需要时刻关注类型之间的解耦，以便该对象日后可以表现出多态性。但 JavaScript，作为一种弱类型的语言，它具有天然的多态性，好像压根不需要考虑类型耦合问题。而目前的 JavaScript 语法里，也确实不支持抽象类的直接实现，我们只能凭借模拟去还原抽象类。因此有一种言论认为，对于前端来说，抽象工厂就是<strong>鸡肋</strong>。</p> <p>抽象工厂模式的学习价值、以及为何被布局在小册 No.2 这个位置背后的思量，我会在文末给大家一五一十地捋清楚。但现在，各位先答应我，<strong>不要跳读</strong>，不要看见“抽象”俩字儿就跑 —— 鸡肋不鸡肋，学明白了才有发言权。</p> <h2 id="一个不简单的简单工厂引发的命案"><a href="#一个不简单的简单工厂引发的命案" class="header-anchor">#</a> 一个不简单的简单工厂引发的命案</h2> <p>在实际的业务中，我们往往面对的复杂度并非数个类、一个工厂可以解决，而是需要动用多个工厂。</p> <p>我们继续看上个小节举出的例子，简单工厂函数最后长这样：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Factory</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> career</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> work
    <span class="token keyword">switch</span><span class="token punctuation">(</span>career<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token string">'coder'</span><span class="token operator">:</span>
            work <span class="token operator">=</span>  <span class="token punctuation">[</span><span class="token string">'写代码'</span><span class="token punctuation">,</span><span class="token string">'写系分'</span><span class="token punctuation">,</span> <span class="token string">'修Bug'</span><span class="token punctuation">]</span> 
            <span class="token keyword">break</span>
        <span class="token keyword">case</span> <span class="token string">'product manager'</span><span class="token operator">:</span>
            work <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'订会议室'</span><span class="token punctuation">,</span> <span class="token string">'写PRD'</span><span class="token punctuation">,</span> <span class="token string">'催更'</span><span class="token punctuation">]</span>
            <span class="token keyword">break</span>
        <span class="token keyword">case</span> <span class="token string">'boss'</span><span class="token operator">:</span>
            work <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'喝茶'</span><span class="token punctuation">,</span> <span class="token string">'看报'</span><span class="token punctuation">,</span> <span class="token string">'见客户'</span><span class="token punctuation">]</span>
        <span class="token keyword">case</span> <span class="token string">'xxx'</span><span class="token operator">:</span>
            <span class="token comment">// 其它工种的职责分配</span>
            <span class="token operator">...</span>
            
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> career<span class="token punctuation">,</span> work<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>乍一看没什么问题，但是经不起推敲呀。首先映入眼帘的 Bug，是我们把 Boss 这个角色和普通员工塞进了一个工厂。大家知道，Boss 和基层员工在职能上差别还是挺大的，具体在员工系统里怎么表现呢？首先他的权限就跟咱们不一样。有一些系统，比如员工绩效评估的打分入口，就只有 Boss 点得进去，对不对？除此之外还有许多操作，是只有管理层可以执行的，因此我们需要对这个群体的对象进行单独的逻辑处理。</p> <p>怎么办？去修改 Factory 的函数体、增加管理层相关的判断和处理逻辑吗？单从功能实现上来说，没问题。但这么做其实是在挖坑——因为公司不仅仅只有这两类人，除此之外还有外包同学、还有保安，他们的权限、职能都存在着质的差别。如果延续这个思路，每考虑到一个新的员工群体，就回去修改一次 Factory 的函数体，这样做糟糕透了——首先，是<strong>Factory会变得异常庞大</strong>，庞大到你每次添加的时候都不敢下手，生怕自己万一写出一个Bug，就会导致整个Factory的崩坏，进而摧毁整个系统；其次，<strong>你坑死了你的队友</strong>：Factory 的逻辑过于繁杂和混乱，没人敢维护它；最后，你还<strong>连带坑了隔壁的测试同学</strong>：你每次新加一个工种，他都不得不对整个Factory 的逻辑进行回归——谁让你的改变是在 Factory 内部原地发生的呢！这一切悲剧的根源只有一个——<strong>没有遵守开放封闭原则</strong>。</p> <p>我们再复习一下开放封闭原则的内容：对拓展开放，对修改封闭。说得更准确点，<strong>软件实体（类、模块、函数）可以扩展，但是不可修改</strong>。楼上这波操作错就错在我们不是在拓展，而是在疯狂地修改。</p> <h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="header-anchor">#</a> 抽象工厂模式</h2> <p>上面这段可能仍有部分同学觉得抽象，也没关系。这里咱们先不急着理解透彻这个干巴巴的概念，先来看这么一个示例：</p> <p>大家知道一部智能手机的基本组成是操作系统（Operating System，我们下面缩写作 OS）和硬件（HardWare）组成。所以说如果我要开一个山寨手机工厂，那我这个工厂里必须是既准备好了操作系统，也准备好了硬件，才能实现手机的<strong>量产</strong>。考虑到操作系统和硬件这两样东西背后也存在不同的厂商，而我现在<strong>并不知道我下一个生产线到底具体想生产一台什么样的手机</strong>，我只知道手机必须有这两部分组成，所以我先来一个抽象类来<strong>约定住这台手机的基本组成</strong>：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">MobilePhoneFactory</span> <span class="token punctuation">{</span>
    <span class="token comment">// 提供操作系统的接口</span>
    <span class="token function">createOS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;抽象工厂方法不允许直接调用，你需要将我重写！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 提供硬件的接口</span>
    <span class="token function">createHardWare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;抽象工厂方法不允许直接调用，你需要将我重写！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>楼上这个类，除了约定手机流水线的通用能力之外，啥也不干。如果你尝试让它干点啥，比如 new 一个 <code>MobilePhoneFactory</code> 实例，并尝试调用它的实例方法。它还会给你报错，提醒你“我不是让你拿去new一个实例的，我就是个定规矩的”。在抽象工厂模式里，楼上这个类就是我们食物链顶端最大的 <code>Boss——AbstractFactory</code>（抽象工厂）。</p> <p>抽象工厂不干活，具体工厂（ConcreteFactory）来干活！当我们明确了生产方案，明确某一条手机生产流水线具体要生产什么样的手机了之后，就可以化抽象为具体，比如我现在想要一个专门生产 Android 系统 + 高通硬件的手机的生产线，我给这类手机型号起名叫 FakeStar，那我就可以为 FakeStar 定制一个具体工厂：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 具体工厂继承自抽象工厂</span>
<span class="token keyword">class</span> <span class="token class-name">FakeStarFactory</span> <span class="token keyword">extends</span> <span class="token class-name">MobilePhoneFactory</span> <span class="token punctuation">{</span>
    <span class="token function">createOS</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 提供安卓系统实例</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">AndroidOS</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">createHardWare</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 提供高通硬件实例</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">QualcommHardWare</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里我们在提供安卓系统的时候，调用了两个构造函数：AndroidOS 和 QualcommHardWare，它们分别用于生成具体的操作系统和硬件实例。像这种被我们拿来用于 new 出具体对象的类，叫做具体产品类（ConcreteProduct）。具体产品类往往不会孤立存在，不同的具体产品类往往有着共同的功能，比如安卓系统类和苹果系统类，它们都是操作系统，都有着可以<strong>操控手机硬件系统</strong>这样一个最基本的功能。因此我们可以用一个<strong>抽象产品（AbstractProduct）类</strong>来声明这一类产品应该具有的基本功能（众：什么抽象产品？？？要这些玩意儿干啥？老夫写代码就是一把梭，为啥不让我老老实实一个一个写具体类？？？大家稍安勿躁，先把例子看完，下文会有解释）</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 定义操作系统这类产品的抽象产品类</span>
<span class="token keyword">class</span> <span class="token class-name">OS</span> <span class="token punctuation">{</span>
    <span class="token function">controlHardWare</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'抽象产品方法不允许直接调用，你需要将我重写！'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 定义具体操作系统的具体产品类</span>
<span class="token keyword">class</span> <span class="token class-name">AndroidOS</span> <span class="token keyword">extends</span> <span class="token class-name">OS</span> <span class="token punctuation">{</span>
    <span class="token function">controlHardWare</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我会用安卓的方式去操作硬件'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">AppleOS</span> <span class="token keyword">extends</span> <span class="token class-name">OS</span> <span class="token punctuation">{</span>
    <span class="token function">controlHardWare</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我会用🍎的方式去操作硬件'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token operator">...</span>
</code></pre></div><p>硬件类产品同理：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 定义手机硬件这类产品的抽象产品类</span>
<span class="token keyword">class</span> <span class="token class-name">HardWare</span> <span class="token punctuation">{</span>
    <span class="token comment">// 手机硬件的共性方法，这里提取了“根据命令运转”这个共性</span>
    <span class="token function">operateByOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'抽象产品方法不允许直接调用，你需要将我重写！'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 定义具体硬件的具体产品类</span>
<span class="token keyword">class</span> <span class="token class-name">QualcommHardWare</span> <span class="token keyword">extends</span> <span class="token class-name">HardWare</span> <span class="token punctuation">{</span>
    <span class="token function">operateByOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我会用高通的方式去运转'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">MiWare</span> <span class="token keyword">extends</span> <span class="token class-name">HardWare</span> <span class="token punctuation">{</span>
    <span class="token function">operateByOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我会用小米的方式去运转'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token operator">...</span>
</code></pre></div><p>好了，如此一来，当我们需要生产一台FakeStar手机时，我们只需要这样做：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 这是我的手机</span>
<span class="token keyword">const</span> myPhone <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FakeStarFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 让它拥有操作系统</span>
<span class="token keyword">const</span> myOS <span class="token operator">=</span> myPhone<span class="token punctuation">.</span><span class="token function">createOS</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 让它拥有硬件</span>
<span class="token keyword">const</span> myHardWare <span class="token operator">=</span> myPhone<span class="token punctuation">.</span><span class="token function">createHardWare</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 启动操作系统(输出‘我会用安卓的方式去操作硬件’)</span>
myOS<span class="token punctuation">.</span><span class="token function">controlHardWare</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 唤醒硬件(输出‘我会用高通的方式去运转’)</span>
myHardWare<span class="token punctuation">.</span><span class="token function">operateByOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>关键的时刻来了——假如有一天，FakeStar过气了，我们需要产出一款新机投入市场，这时候怎么办？我们是不是<strong>不需要对抽象工厂MobilePhoneFactory做任何修改</strong>，只需要拓展它的种类：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">newStarFactory</span> <span class="token keyword">extends</span> <span class="token class-name">MobilePhoneFactory</span> <span class="token punctuation">{</span>
    <span class="token function">createOS</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 操作系统实现代码</span>
    <span class="token punctuation">}</span>
    <span class="token function">createHardWare</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 硬件实现代码</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这么个操作，<strong>对原有的系统不会造成任何潜在影响</strong> 所谓的“对拓展开放，对修改封闭”就这么圆满实现了。前面我们之所以要实现<strong>抽象产品类</strong>，也是同样的道理。</p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>大家现在回头对比一下抽象工厂和简单工厂的思路，思考一下：它们之间有哪些异同？</p> <p>它们的共同点，在于都<strong>尝试去分离一个系统中变与不变的部分</strong>。它们的不同在于<strong>场景的复杂度</strong>。在简单工厂的使用场景里，处理的对象是类，并且是一些非常好对付的类——它们的共性容易抽离，同时因为逻辑本身比较简单，故而不苛求代码可扩展性。抽象工厂本质上处理的其实也是类，但是是一帮非常棘手、繁杂的类，这些类中不仅能划分出门派，还能划分出等级，同时存在着千变万化的扩展可能性——这使得我们必须对<strong>共性</strong>作更特别的处理、使用抽象类去降低扩展的成本，同时需要对类的性质作划分，于是有了这样的四个关键角色：</p> <ul><li><strong>抽象工厂（抽象类，它不能被用于生成具体实例）：</strong> 用于声明最终目标产品的共性。在一个系统里，抽象工厂可以有多个（大家可以想象我们的手机厂后来被一个更大的厂收购了，这个厂里除了手机抽象类，还有平板、游戏机抽象类等等），每一个抽象工厂对应的这一类的产品，被称为“产品族”。</li> <li><strong>具体工厂（用于生成产品族里的一个具体的产品）：</strong> 继承自抽象工厂、实现了抽象工厂里声明的那些方法，用于创建具体的产品的类。</li> <li><strong>抽象产品（抽象类，它不能被用于生成具体实例）：</strong> 上面我们看到，具体工厂里实现的接口，会依赖一些类，这些类对应到各种各样的具体的细粒度产品（比如操作系统、硬件等），这些具体产品类的共性各自抽离，便对应到了各自的抽象产品类。</li> <li><strong>具体产品（用于生成产品族里的一个具体的产品所依赖的更细粒度的产品）：</strong> 比如我们上文中具体的一种操作系统、或具体的一种硬件等。</li></ul> <p>抽象工厂模式的定义，是<strong>围绕一个超级工厂创建其他工厂</strong>。本节内容对一些工作年限不多的同学来说可能不太友好，但抽象工厂目前来说在JS世界里也应用得并不广泛，所以大家不必拘泥于细节，只需留意以下三点：</p> <ol><li>学会用 ES6 模拟 JAVA 中的抽象类；</li> <li>了解抽象工厂模式中四个角色的定位与作用；</li> <li>对“开放封闭原则”形成自己的理解，知道它好在哪，知道执行它的必要性。</li></ol> <p>如果能对这三点有所掌握，那么这一节的目的就达到了，最难搞、最难受的抽象工厂也就告一段落了。</p> <h2 id="最后-再跟大家谈谈学习"><a href="#最后-再跟大家谈谈学习" class="header-anchor">#</a> 最后，再跟大家谈谈学习</h2> <p>现在我们回到开篇抛出的那个问题——抽象工厂对于各位而言的价值是什么？这么一个看似鸡肋、其实也确实不怎么常用的一个设计模式，凭什么值得我们花这么大力气去理解它？原因有三：</p> <p><strong>其一：</strong> 开篇我们说过，<strong>前端工程师首先是软件工程师</strong>。只会写 JavaScript、只理解 JavaScript、只通过 JavaScript 去理解软件世界，是一件可怕的事情，它会窄化你的技术视野——因为 JavaScript 只是编程语言中的一个分支，准确地说，它是一个后辈。虽说它确实很流行，但它还不够强大（正是因为不够强大，所以在演化发展的过程中必然需要借鉴其它优秀语言的优秀特性，也会渐渐遇到其它语言的应用场景，不信大家看看 ES6789 都做了什么，再看看遍地开花的 TypeScript）。</p> <p>但写这本小册并不是为了把大家指去学 Java/C++，而是为了以最小的时间成本帮大家去理解设计模式的套路和原则。比起要求大家为了这个设计模式去理解强类型语言、去理解强类型语言里的应用场景，我更希望能在这儿用 JavaScript 把这个东西给说清楚，把那些关键的设计模式概念在这儿给大家引出来——哪怕你当下用到它的场景还不是那么多（相信以当下前端语言和前端应用的发展速度和发展趋势来看，它会有用的：））。</p> <p><strong>其二：</strong> 在大家今后的职业生涯里，可能会不止一次地遇到服务端/客户端出身、或者单纯对受试者知识广度有疯狂执念的各种不同背景不同脑回路的面试官。在他们的世界里，不知道抽象工厂就像不知道 <code>this</code> 一样恐怖：）。所以，<strong>要学</strong>。</p> <p><strong>其三：</strong> 也是最重要的一点。前面我们说过，设计模式的“术”说到底是在佐证它的“道”。充分理解了设计原则后，设计模式纵有 1w 种也难不倒大家。<strong>抽象工厂是佐证“开放封闭原则”的良好素材</strong>，通过本节的学习，相信大家会对这个抽象的概念有更加具体和感性的认知。在后面的章节中，“开放封闭”作为各位的老朋友，会被反复提及。有了本节的平稳过渡，相信大家在后续的学习中可以真正做到心中有数、游刃有余。</p> <p>说了这么多，无非是想传达给大家一个学习态度：<strong>不要小看那些看似“无用”的知识</strong>。</p> <p>技术，尤其是前端技术，它的更新迭代速度是非常快的。仅仅因为“这个技术点我现在用不到”而推开摆在眼前的知识，是一种非常糟糕的学习方法——它会极大地限制你的能力和你职业生涯的可能性。举个例子，React 新版本推出的 Fiber 架构现在很火，很多同学认为这是个特别新潮的玩意儿——它新吗？新个屁！作为一种架构模式，它在软件领域早就有过不同姿势的生产实践了，React 并不是 Fiber 的发明者，而是 Fiber 的使用者和受益者。</p> <p>同理，包括 ES2015 刚出来的时候，有同学说这个也没见过、那个也要重新学，累死了累死了，学不动了想转行...哎，其实它们都是软件世界里存在了很久很久的模式和知识点啊同学们。试想如果这份知识曾经摆在你面前的时候你没有拒绝它，此刻你的学习成本又该低了多少呢？</p> <p>设计模式之外的东西，我们点到即止，剩下的就看大家的悟性和造化了。 接下来，我们一起看点更好玩的东西~</p> <p>（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）</p> <p>单例模式</p> <p><strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点</strong>，这样的模式就叫做单例模式。</p> <p>单例模式是设计模式中相对较为容易理解、容易上手的一种模式，同时因为其具有广泛的应用场景，也是<strong>面试题里的常客</strong>。因此单例模式这块我们除了讲解单例模式的原理及其在 Vuex 中的应用实践(本节)，还会附上两道面试真题供大家练手(下节)。</p> <h2 id="单例模式的实现思路"><a href="#单例模式的实现思路" class="header-anchor">#</a> 单例模式的实现思路</h2> <p>现在我们先不考虑单例模式的应用场景，单看它的实现，思考这样一个问题：如何才能保证一个类仅有一个实例？
一般情况下，当我们创建了一个类（本质是构造函数）后，可以通过new关键字调用构造函数进而生成任意多的实例对象。像这样：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">SingleDog</span> <span class="token punctuation">{</span>
    <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我是一个单例对象'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingleDog</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingleDog</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// false</span>
s1 <span class="token operator">===</span> s2
</code></pre></div><p>楼上我们先 new 了一个 s1，又 new 了一个 s2，很明显 s1 和 s2 之间没有任何瓜葛，两者是相互独立的对象，各占一块内存空间。而单例模式想要做到的是，<strong>不管我们尝试去创建多少次，它都只给你返回第一次所创建的那唯一的一个实例</strong>。</p> <p>要做到这一点，就需要构造函数<strong>具备判断自己是否已经创建过一个实例</strong>的能力。我们现在把这段判断逻辑写成一个静态方法(其实也可以直接写入构造函数的函数体里）：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">SingleDog</span> <span class="token punctuation">{</span>
    <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我是一个单例对象'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 判断是否已经new过1个实例</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>SingleDog<span class="token punctuation">.</span>instance<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 若这个唯一的实例不存在，那么先创建它</span>
            SingleDog<span class="token punctuation">.</span>instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingleDog</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 如果这个唯一的实例已经存在，则直接返回</span>
        <span class="token keyword">return</span> SingleDog<span class="token punctuation">.</span>instance
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> s1 <span class="token operator">=</span> SingleDog<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> s2 <span class="token operator">=</span> SingleDog<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// true</span>
s1 <span class="token operator">===</span> s2
</code></pre></div><p>除了楼上这种实现方式之外，getInstance的逻辑还可以用<strong>闭包</strong>来实现：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>SingleDog<span class="token punctuation">.</span>getInstance <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 定义自由变量instance，模拟私有变量</span>
    <span class="token keyword">let</span> instance <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 判断自由变量是否为null</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>instance<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果为null则new出唯一实例</span>
            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingleDog</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> instance
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>可以看出，在getInstance方法的判断和拦截下，我们不管调用多少次，SingleDog都只会给我们返回一个实例，s1和s2现在都指向这个唯一的实例。</p> <h2 id="生产实践-vuex中的单例模式"><a href="#生产实践-vuex中的单例模式" class="header-anchor">#</a> 生产实践：Vuex中的单例模式</h2> <p>近年来，基于 Flux 架构的状态管理工具层出不穷，其中应用最广泛的要数 Redux 和 Vuex。无论是 Redux 和 Vuex，它们都实现了一个全局的 Store 用于存储应用的所有状态。这个 Store 的实现，正是单例模式的典型应用。这里我们以 Vuex 为例，研究一下单例模式是怎么发光发热的：</p> <h3 id="理解-vuex-中的-store"><a href="#理解-vuex-中的-store" class="header-anchor">#</a> 理解 Vuex 中的 Store</h3> <blockquote><p>Vuex 使用单一状态树，用一个对象就包含了全部的应用层级状态。至此它便作为一个“唯一数据源 (SSOT)”而存在。这也意味着，每个应用将仅仅包含一个 store 实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。 ——Vuex官方文档</p></blockquote> <p>在Vue中，组件之间是独立的，组件间通信最常用的办法是 props（限于父组件和子组件之间的通信），稍微复杂一点的（比如兄弟组件间的通信）我们通过自己实现简单的事件监听函数也能解决掉。</p> <p>但当组件非常多、组件间关系复杂、且嵌套层级很深的时候，这种原始的通信方式会使我们的逻辑变得复杂难以维护。这时最好的做法是将共享的数据抽出来、放在全局，供组件们按照一定的的规则去存取数据，保证状态以一种可预测的方式发生变化。于是便有了 Vuex，这个用来存放共享数据的唯一数据源，就是 Store。</p> <p>关于 Vuex 的细节，大家可以参考<a href="https://link.juejin.cn/?target=https%3A%2F%2Fvuex.vuejs.org%2Fzh%2F" target="_blank" rel="noopener noreferrer">Vuex的官方文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，此处提及 Vuex，除了为了拓宽大家的知识面，更重要的是为了说明单例模式在生产实践中广泛的应用和不可或缺的地位。如果对 Vuex 没有兴趣，那么大家只需关注“一个 Vue 实例只能对应一个 Store”这一点即可。</p> <h3 id="vuex如何确保store的唯一性"><a href="#vuex如何确保store的唯一性" class="header-anchor">#</a> Vuex如何确保Store的唯一性</h3> <p>我们先来看看如何在项目中引入 Vuex：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 安装vuex插件</span>
Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Vuex<span class="token punctuation">)</span>

<span class="token comment">// 将store注入到Vue实例中</span>
<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    el<span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
    store
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>通过调用<code>Vue.use()</code>方法，我们安装了 Vuex 插件。Vuex 插件是一个对象，它在内部实现了一个 install 方法，这个方法会在插件安装时被调用，从而把 Store 注入到Vue实例里去。也就是说每 install 一次，都会尝试给 Vue 实例注入一个 Store。</p> <p>在 install 方法里，有一段逻辑和我们楼上的 <code>getInstance</code> 非常相似的逻辑：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> Vue <span class="token comment">// 这个Vue的作用和楼上的instance作用一样</span>
<span class="token operator">...</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">install</span> <span class="token punctuation">(</span><span class="token parameter">_Vue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 判断传入的Vue实例对象是否已经被install过Vuex插件（是否有了唯一的state）</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Vue <span class="token operator">&amp;&amp;</span> _Vue <span class="token operator">===</span> Vue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>
        <span class="token string">'[vuex] already installed. Vue.use(Vuex) should be called only once.'</span>
      <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 若没有，则为这个Vue实例对象install一个唯一的Vuex</span>
  Vue <span class="token operator">=</span> _Vue
  <span class="token comment">// 将Vuex的初始化逻辑写进Vue的钩子函数里</span>
  <span class="token function">applyMixin</span><span class="token punctuation">(</span>Vue<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>楼上便是 Vuex 源码中单例模式的实现办法了，套路可以说和我们的<code>getInstance</code>如出一辙。通过这种方式，可以保证一个 Vue 实例（即一个 Vue 应用）只会被 install 一次 Vuex 插件，所以每个 Vue 实例只会拥有一个全局的 Store。</p> <h2 id="小结-2"><a href="#小结-2" class="header-anchor">#</a> 小结</h2> <p>这里大家不妨开个脑洞，思考一下：如果我在 install 里没有实现单例模式，会带来什么样的麻烦？</p> <p>我们通过上面的源码解析可以看出，每次 install 都会为Vue实例初始化一个 Store。假如 install 里没有单例模式的逻辑，那我们如果在一个应用里不小心多次安装了插件：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 在主文件里安装Vuex</span>
Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Vuex<span class="token punctuation">)</span>

<span class="token operator">...</span><span class="token punctuation">(</span>中间添加<span class="token operator">/</span>修改了一些store的数据<span class="token punctuation">)</span>

<span class="token comment">// 在后续的逻辑里不小心又安装了一次</span>
Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Vuex<span class="token punctuation">)</span>
</code></pre></div><p>失去了单例判断能力的 install 方法，会为当前的Vue实例重新注入一个新的 Store，也就是说你中间的那些数据操作全都没了，一切归 0。因此，单例模式在此处是非常必要的。</p> <p>除了说在 Vuex 中大展身手，我们在 Redux、jQuery 等许多优秀的前端库里也都能看到单例模式的身影。重要的单例模式自然在面试中有了重要的地位，下一节，我们就来看两道面试真题~</p> <p>（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）</p> <h2 id="实现一个-storage"><a href="#实现一个-storage" class="header-anchor">#</a> 实现一个 Storage</h2> <h3 id="描述"><a href="#描述" class="header-anchor">#</a> 描述</h3> <blockquote><p>实现Storage，使得该对象为单例，基于 localStorage 进行封装。实现方法 setItem(key,value) 和 getItem(key)。</p></blockquote> <h3 id="思路"><a href="#思路" class="header-anchor">#</a> 思路</h3> <p>拿到单例模式相关的面试题，大家首先要做的是回忆我们上个小节的“基本思路”部分——至少要记起来<code>getInstance</code>方法和<code>instance</code>这个变量是干啥的。</p> <p>具体实现上，把判断逻辑写入静态方法或者构造函数里都没关系，最好能把闭包的版本也写出来，多多益善。</p> <p>总之有了上节的基础，这个题简直是默写！</p> <blockquote><p>实现：静态方法版</p></blockquote> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 定义Storage</span>
<span class="token keyword">class</span> <span class="token class-name">Storage</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 判断是否已经new过1个实例</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Storage<span class="token punctuation">.</span>instance<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 若这个唯一的实例不存在，那么先创建它</span>
            Storage<span class="token punctuation">.</span>instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Storage</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 如果这个唯一的实例已经存在，则直接返回</span>
        <span class="token keyword">return</span> Storage<span class="token punctuation">.</span>instance
    <span class="token punctuation">}</span>
    <span class="token function">getItem</span> <span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">setItem</span> <span class="token punctuation">(</span><span class="token parameter">key<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> storage1 <span class="token operator">=</span> Storage<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> storage2 <span class="token operator">=</span> Storage<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

storage1<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'李雷'</span><span class="token punctuation">)</span>
<span class="token comment">// 李雷</span>
storage1<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span>
<span class="token comment">// 也是李雷</span>
storage2<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span>

<span class="token comment">// 返回true</span>
storage1 <span class="token operator">===</span> storage2
</code></pre></div><blockquote><p>实现： 闭包版</p></blockquote> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 先实现一个基础的StorageBase类，把getItem和setItem方法放在它的原型链上</span>
<span class="token keyword">function</span> <span class="token function">StorageBase</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token class-name">StorageBase</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getItem</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token class-name">StorageBase</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">setItem</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">key<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 以闭包的形式创建一个引用自由变量的构造函数</span>
<span class="token keyword">const</span> Storage <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> instance <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// 判断自由变量是否为null</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>instance<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果为null则new出唯一实例</span>
            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StorageBase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> instance
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// 这里其实不用 new Storage 的形式调用，直接 Storage() 也会有一样的效果 </span>
<span class="token keyword">const</span> storage1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Storage</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> storage2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Storage</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

storage1<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'李雷'</span><span class="token punctuation">)</span>
<span class="token comment">// 李雷</span>
storage1<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span>
<span class="token comment">// 也是李雷</span>
storage2<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span>

<span class="token comment">// 返回true</span>
storage1 <span class="token operator">===</span> storage2
</code></pre></div><h2 id="实现一个全局的模态框"><a href="#实现一个全局的模态框" class="header-anchor">#</a> 实现一个全局的模态框</h2> <h3 id="描述-2"><a href="#描述-2" class="header-anchor">#</a> 描述</h3> <blockquote><p>实现一个全局唯一的Modal弹框</p></blockquote> <h3 id="思路-2"><a href="#思路-2" class="header-anchor">#</a> 思路</h3> <p>这道题比较经典，基本上所有讲单例模式的文章都会以此为例，同时它也是早期单例模式在前端领域的最集中体现。</p> <p>万变不离其踪，记住<code>getInstance</code>方法、记住<code>instance</code>变量、记住闭包和静态方法，这个题除了要多写点 HTML 和 CSS 之外，对大家来说完全不成问题。</p> <h3 id="实现"><a href="#实现" class="header-anchor">#</a> 实现</h3> <p>完整代码如下：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>en<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>UTF-8<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>单例模式弹框<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
    <span class="token selector">#modal</span> <span class="token punctuation">{</span>
        <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
        <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
        <span class="token property">line-height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
        <span class="token property">position</span><span class="token punctuation">:</span> fixed<span class="token punctuation">;</span>
        <span class="token property">left</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
        <span class="token property">top</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
        <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translate</span><span class="token punctuation">(</span>-50%<span class="token punctuation">,</span> -50%<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token property">border</span><span class="token punctuation">:</span> 1px solid black<span class="token punctuation">;</span>
        <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>open<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>打开弹框<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>close<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>关闭弹框<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
    <span class="token comment">// 核心逻辑，这里采用了闭包思路来实现单例模式</span>
    <span class="token keyword">const</span> Modal <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword">let</span> modal <span class="token operator">=</span> <span class="token keyword">null</span>
    	<span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>modal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            	modal <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span>
            	modal<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">'我是一个全局唯一的Modal'</span>
            	modal<span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token string">'modal'</span>
            	modal<span class="token punctuation">.</span>style<span class="token punctuation">.</span>display <span class="token operator">=</span> <span class="token string">'none'</span>
            	document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>modal<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> modal
    	<span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    
    <span class="token comment">// 点击打开按钮展示模态框</span>
    document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'open'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 未点击则不创建modal实例，避免不必要的内存占用;此处不用 new Modal 的形式调用也可以，和 Storage 同理</span>
    	<span class="token keyword">const</span> modal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Modal</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    	modal<span class="token punctuation">.</span>style<span class="token punctuation">.</span>display <span class="token operator">=</span> <span class="token string">'block'</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    
    <span class="token comment">// 点击关闭按钮隐藏模态框</span>
    document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'close'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword">const</span> modal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Modal</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    	<span class="token keyword">if</span><span class="token punctuation">(</span>modal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	    modal<span class="token punctuation">.</span>style<span class="token punctuation">.</span>display <span class="token operator">=</span> <span class="token string">'none'</span>
    	<span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>是不是发现又是熟悉的套路？又可以默写了？（ES6 版本的实现大家自己尝试默写一下，相信对现在的你来说已经非常简单了）。</p> <p>这就是单例模式面试题的特点，准确地说，是所有设计模式相关面试题的特点——牢记核心思路，就能举一反三。所以说设计模式的学习是典型的一分耕耘一分收获，性价比极高。</p> <p>（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）</p> <p>原型模式</p> <p>原型模式不仅是一种设计模式，它还是一种<strong>编程范式</strong>（programming paradigm），是 JavaScript 面向对象系统实现的根基。</p> <p>在原型模式下，当我们想要创建一个对象时，会先找到一个对象作为原型，然后通过<strong>克隆原型</strong>的方式来创建出一个与原型一样（共享一套数据/方法）的对象。在 JavaScript 里，<code>Object.create</code>方法就是原型模式的天然实现——准确地说，只要我们还在借助<code>Prototype</code>来实现对象的创建和原型的继承，那么我们就是在应用原型模式。</p> <p>有的设计模式资料中会强调，原型模式就是拷贝出一个新对象，认为在 JavaScript 类里实现了深拷贝方法才算是应用了原型模式。这是非常典型的对 JAVA/C++ 设计模式的生搬硬套，更是对 JavaScript 原型模式的一种误解。</p> <p>事实上，在JAVA中，确实存在原型模式相关的克隆接口规范。但在 JavaScript 中，我们使用原型模式，并不是为了得到一个副本，而是为了得到与构造函数（类）相对应的类型的实例、实现数据/方法的共享。克隆是实现这个目的的方法，但克隆本身并不是我们的目的。</p> <h2 id="以类为中心的语言和以原型为中心的语言"><a href="#以类为中心的语言和以原型为中心的语言" class="header-anchor">#</a> 以类为中心的语言和以原型为中心的语言</h2> <p>相信很多小伙伴读到这儿还会有些迷惑：使用 JavaScript 以来，我确实离不开<code>Prototype</code>，按照上面的说法，也算是原型模式重度用户了。但这个原型模式用得我一脸懵逼啊——难道我还有除了<code>Prototype</code>以外的选择？</p> <h3 id="java-中的类"><a href="#java-中的类" class="header-anchor">#</a> Java 中的类</h3> <p>作为 JavaScript 开发者，我们确实没有别的选择 —— 毕竟开头我们说过，原型模式是 JavaScript 这门语言面向对象系统的根本。但在其它语言，比如 JAVA 中，类才是它面向对象系统的根本。所以说在 JAVA 中，我们可以选择不使用原型模式 —— 这样一来，所有的实例都必须要从类中来，当我们希望创建两个一模一样的实例时，就只能这样做（假设实例从 Dog 类中来,必传参数为姓名、性别、年龄和品种）：</p> <div class="language- extra-class"><pre class="language-text"><code>Dog dog = new Dog('旺财', 'male', 3, '柴犬')
Dog dog_copy = new Dog('旺财', 'male', 3, '柴犬')
</code></pre></div><p>没错，我们不得不把一模一样的参数传两遍，非常麻烦。而原型模式允许我们通过调用克隆方法的方式达到同样的目的，比较方便，所以 Java 专门针对原型模式设计了一套接口和方法，在必要的场景下会通过原型方法来应用原型模式。当然，在更多的情况下，Java 仍以“实例化类”这种方式来创建对象。</p> <p>所以说在以类为中心的语言中，原型模式确实不是一个必选项，它只有在特定的场景下才会登场。</p> <h3 id="javascript-中的-类"><a href="#javascript-中的-类" class="header-anchor">#</a> JavaScript 中的“类”</h3> <p>这时有一部分小伙伴估计要炸毛了：啥？？？JavaScript 只能用<code>Prototype</code>？我看你还活在上世纪，ES6 早就支持类了！现在我们 JavaScript 也是以类为中心的语言了。</p> <p>这波同学的思想非常危险，因为 ES6 的类其实是原型继承的语法糖:</p> <blockquote><p>ECMAScript 2015 中引入的 JavaScript 类实质上是 JavaScript 现有的基于原型的继承的语法糖。类语法不会为 JavaScript 引入新的面向对象的继承模型。 ——MDN</p></blockquote> <p>当我们尝试用 class 去定义一个 Dog 类时：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name <span class="token punctuation">,</span>age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
   <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age
  <span class="token punctuation">}</span>
  
  <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'肉骨头真好吃'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>其实完全等价于写了这么一个构造函数:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Dog</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age
<span class="token punctuation">}</span>
<span class="token class-name">Dog</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">eat</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'肉骨头真好吃'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>所以说 JavaScript 这门语言的根本就是原型模式。在 Java 等强类型语言中，原型模式的出现是为了实现类型之间的解耦。而 JavaScript 本身类型就比较模糊，不存在类型耦合的问题，所以说咱们平时<strong>根本不会刻意地去使用原型模式</strong>。因此我们此处不必强行把原型模式当作一种设计模式去理解，把它作为一种编程范式来讨论会更合适。</p> <h2 id="谈原型模式-其实是谈原型范式"><a href="#谈原型模式-其实是谈原型范式" class="header-anchor">#</a> 谈原型模式，其实是谈原型范式</h2> <p>原型编程范式的核心思想就是<strong>利用实例来描述对象，用实例作为定义对象和继承的基础</strong>。在 JavaScript 中，原型编程范式的体现就是<strong>基于原型链的继承</strong>。这其中，对原型、原型链的理解是关键。</p> <h3 id="原型"><a href="#原型" class="header-anchor">#</a> 原型</h3> <p>在 JavaScript 中，每个构造函数都拥有一个<code>prototype</code>属性，它指向构造函数的原型对象，这个原型对象中有一个 constructor 属性指回构造函数；每个实例都有一个<code>__proto__</code>属性，当我们使用构造函数去创建实例时，实例的<code>__proto__</code>属性就会指向构造函数的原型对象。 具体来说，当我们这样使用构造函数创建一个对象时：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 创建一个Dog构造函数</span>
<span class="token keyword">function</span> <span class="token function">Dog</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age
<span class="token punctuation">}</span>
<span class="token class-name">Dog</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">eat</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'肉骨头真好吃'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 使用Dog构造函数创建dog实例</span>
<span class="token keyword">const</span> dog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token string">'旺财'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
</code></pre></div><p>这段代码里的几个实体之间就存在着这样的关系：</p> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/11/1696bfe41aa0a184~tplv-t2oaga2asx-watermark.awebp" alt="img"></p> <h3 id="原型链"><a href="#原型链" class="header-anchor">#</a> 原型链</h3> <p>现在我在上面那段代码的基础上，进行两个方法调用:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 输出&quot;肉骨头真好吃&quot;</span>
dog<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 输出&quot;[object Object]&quot;</span>
dog<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>明明没有在 dog 实例里手动定义 eat 方法和 toString 方法，它们还是被成功地调用了。这是因为当我试图访问一个 JavaScript 实例的属性/方法时，它首先搜索这个实例本身；当发现实例没有定义对应的属性/方法时，它会转而去搜索实例的原型对象；如果原型对象中也搜索不到，它就去搜索原型对象的原型对象，这个搜索的轨迹，就叫做原型链。</p> <p>以我们的 eat 方法和 toString 方法的调用过程为例，它的搜索过程就是这样子的：</p> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/11/1696bfd959ce30b3~tplv-t2oaga2asx-watermark.awebp" alt="img"></p> <p>楼上这些彼此相连的<code>prototype</code>，就组成了一个原型链。 注： 几乎所有 JavaScript 中的对象都是位于原型链顶端的 Object 的实例，除了<code>Object.prototype</code>（当然，如果我们手动用<code>Object.create(null)</code>创建一个没有任何原型的对象，那它也不是 Object 的实例）。</p> <p>以上为大家介绍了原型、原型链等 JavaScript 中核心的基础知识。这些不仅是基础中的基础，也是面试中的重点。此外在面试中，一些面试官可能会刻意混淆 JavaScript 中原型范式和强类型语言中原型模式的区别，当他们这么做的时候不一定是因为对语言、对设计模式的理解有问题，而很有可能是为了考察你<strong>对象的深拷贝</strong>。</p> <h3 id="对象的深拷贝"><a href="#对象的深拷贝" class="header-anchor">#</a> 对象的深拷贝</h3> <p>这类题目的发问方式又很多，除了“模拟 JAVA 中的克隆接口”、“JavaScript 实现原型模式”以外，它更常见、更友好的发问形式是“请实现JS中的深拷贝”。</p> <p>实现 JavaScript 中的深拷贝，有一种非常取巧的方式 —— JSON.stringify：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> liLei <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">'lilei'</span><span class="token punctuation">,</span>
    age<span class="token operator">:</span> <span class="token number">28</span><span class="token punctuation">,</span>
    habits<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'coding'</span><span class="token punctuation">,</span> <span class="token string">'hiking'</span><span class="token punctuation">,</span> <span class="token string">'running'</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> liLeiStr <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>liLei<span class="token punctuation">)</span>
<span class="token keyword">const</span> liLeiCopy <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>liLeiStr<span class="token punctuation">)</span>
liLeiCopy<span class="token punctuation">.</span>habits<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> 
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'李雷副本的habits数组是'</span><span class="token punctuation">,</span> liLeiCopy<span class="token punctuation">.</span>habits<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'李雷的habits数组是'</span><span class="token punctuation">,</span>  liLei<span class="token punctuation">.</span>habits<span class="token punctuation">)</span>
</code></pre></div><p>丢进控制台检验一下，我们发现引用类型也被成功拷贝了，副本和本体相互不干扰，正合我意~</p> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/6/169f0e60f4a6e77b~tplv-t2oaga2asx-watermark.awebp" alt="img"> 但是注意，这个方法存在一些局限性，比如无法处理 function、无法处理正则等等——只有当你的对象是一个严格的 JSON 对象时，可以顺利使用这个方法。在面试过程中，大家答出这个答案没有任何问题，但不要仅仅答这一种做法。</p> <p><strong>深拷贝没有完美方案，每一种方案都有它的边界 case</strong>。而面试官向你发问也并非是要求你破解人类未解之谜，多数情况下，他只是希望考查你对<strong>递归</strong>的熟练程度。所以递归实现深拷贝的核心思路，大家需要重点掌握（解析在注释里）：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">deepClone</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果是 值类型 或 null，则直接return</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> obj <span class="token operator">!==</span> <span class="token string">'object'</span> <span class="token operator">||</span> obj <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> obj
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 定义结果对象</span>
    <span class="token keyword">let</span> copy <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    
    <span class="token comment">// 如果对象是数组，则定义结果数组</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Array<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        copy <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 遍历对象的key</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果key是对象的自有属性</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 递归调用深拷贝方法</span>
            copy<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">return</span> copy
<span class="token punctuation">}</span> 
</code></pre></div><p>调用深拷贝方法，若属性为值类型，则直接返回；若属性为引用类型，则递归遍历。这就是我们在解这一类题时的核心的方法。</p> <h3 id="拓展阅读"><a href="#拓展阅读" class="header-anchor">#</a> 拓展阅读</h3> <p>深拷贝在命题时，可发挥的空间主要在于针对不同数据结构的处理，比如除了考虑 Array、Object，还需要考虑一些其它的数据结构（Map、Set 等）；此外还有一些极端 case（循环引用等）的处理等等。深拷贝的实现细节，这里为大家推荐两个阅读材料：</p> <ul><li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fjquery%2Fjquery%2Fblob%2F1472290917f17af05e98007136096784f9051fab%2Fsrc%2Fcore.js%23L121" target="_blank" rel="noopener noreferrer">jQuery中的extend方法源码<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000016672263" target="_blank" rel="noopener noreferrer">深拷贝的终极探索<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <p>想要在深拷贝这一命题上拿高分的同学，不妨点开一看，相信你的收获会比你想象中更多~</p> <p>（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">3/21/2022, 9:01:05 PM</span></div></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/设计模式/2.结构型.html">
        /设计模式/2.结构型.html
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.b51e4ccd.js" defer></script><script src="/assets/js/2.7229199a.js" defer></script><script src="/assets/js/137.eb295fce.js" defer></script>
  </body>
</html>
