(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{417:function(t,e,a){"use strict";a.r(e);var s=a(45),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"基础篇"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基础篇"}},[t._v("#")]),t._v(" 基础篇")]),t._v(" "),a("h2",{attrs:{id:"jsx"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jsx"}},[t._v("#")]),t._v(" jsx")]),t._v(" "),a("p",[t._v("被babel处理后："),a("code",[t._v("<xx> => React.createElement()")])]),t._v(" "),a("p",[t._v("被createElement处理后：react element")]),t._v(" "),a("p",[t._v("reconcile之后：fiber，形成fiber树")]),t._v(" "),a("h2",{attrs:{id:"component"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#component"}},[t._v("#")]),t._v(" Component")]),t._v(" "),a("p",[t._v("定义：渲染 + 更新的类和函数")]),t._v(" "),a("p",[t._v("类组件加入了updater对象。setState和forceUpdate本质是updater的")]),t._v(" "),a("p",[t._v("类组件源码：绑定props和context，置空refs，绑定updater，定义setState和forceUpdate到组件原型")]),t._v(" "),a("p",[t._v("函数组件无法像类组件实例一样保存状态，组件更新都是函数执行，变量会重新声明")]),t._v(" "),a("p",[t._v("为了保存状态而产生hooks")]),t._v(" "),a("p",[t._v("5种组件通信：props、ref、redux、context、event bus")]),t._v(" "),a("p",[t._v("组件强化：继承、自定义hooks、hoc")]),t._v(" "),a("h2",{attrs:{id:"state"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#state"}},[t._v("#")]),t._v(" state")]),t._v(" "),a("p",[t._v("同步还是异步？batchUpdate以外同步，内部是异步")]),t._v(" "),a("p",[t._v("setState的逻辑：产生优先级lane，render合并state，commit完成DOM更新，callback执行")]),t._v(" "),a("p",[t._v("类组件限制state更新视图：PureComponent、shouldComponentUpdate")]),t._v(" "),a("p",[t._v("setState的源码：调用updater的enqueueSetState，创建一个update，enqueue进fiber的更新队列，开始"),a("strong",[t._v("调度更新（scheduleUpdateOnFiber）")])]),t._v(" "),a("p",[t._v("batchUpdate涉及事件系统，事件派发时会调用batchedEventUpdates，里面设置batcheUpdate的开关")]),t._v(" "),a("p",[t._v("在scheduleUpdateOnFiber中，根据开关确定是否开启批量更新")]),t._v(" "),a("p",[t._v("异步环境开启批更新：unstable_batchUpdates")]),t._v(" "),a("p",[t._v("提升更新优先级：flush")]),t._v(" "),a("p",[t._v("函数组件的ueState底层也调用了scheduleUpdateOnFiber，事件驱动情况下都有批量更新规则")]),t._v(" "),a("h2",{attrs:{id:"props"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#props"}},[t._v("#")]),t._v(" props")]),t._v(" "),a("p",[t._v("监听props：类组件getDerivedStateFromProps，函数组件useEffect")]),t._v(" "),a("h2",{attrs:{id:"lifecycle"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lifecycle"}},[t._v("#")]),t._v(" lifeCycle")]),t._v(" "),a("h3",{attrs:{id:"mount"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mount"}},[t._v("#")]),t._v(" mount")]),t._v(" "),a("p",[t._v("cons -> getDer | willMount + receiveProps -> render -> getSnapshot -> 更新dom -> didMount")]),t._v(" "),a("h3",{attrs:{id:"update"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#update"}},[t._v("#")]),t._v(" update")]),t._v(" "),a("p",[a("strong",[t._v("父render + props改变")])]),t._v(" "),a("p",[t._v("willReceiveProps -> getDer -> shouldUpdate -> render -> getSnapshot -> 更新dom -> didUpdate")]),t._v(" "),a("p",[a("strong",[t._v("state")])]),t._v(" "),a("p",[t._v("shouldUpdate ...")]),t._v(" "),a("p",[a("strong",[t._v("forceUpdate")])]),t._v(" "),a("p",[t._v("render")]),t._v(" "),a("h3",{attrs:{id:"函数组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#函数组件"}},[t._v("#")]),t._v(" 函数组件")]),t._v(" "),a("p",[t._v("useEffect是异步执行的")]),t._v(" "),a("p",[t._v("而useLayoutEffect同步执行，类似didMount，阻塞绘制")]),t._v(" "),a("h2",{attrs:{id:"ref"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ref"}},[t._v("#")]),t._v(" Ref")]),t._v(" "),a("p",[t._v("useRef（）")]),t._v(" "),a("p",[t._v("hooks与组件的fiber管理，ref挂载到fiber")]),t._v(" "),a("h3",{attrs:{id:"forwardref"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#forwardref"}},[t._v("#")]),t._v(" forwardRef")]),t._v(" "),a("p",[t._v("函数组件在父组件层不能直接传入ref")]),t._v(" "),a("p",[t._v("需要用forwardRef转发")]),t._v(" "),a("p",[t._v("转发ref")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Child() {\n  const {propsRef} = props\n  return (\n    <div ref={propsRef} />\n)\n}\n\nCpn() {\n  return (\n    <Child propsRef={this.props.propsRef} /> \n)\n}\n\nconst NewCpn = React.forwardRef((props, ref) =>  <Cpn propsRef={ref}, {...props}>)\n\nApp() {\n  return (\n    <NewCpn ref={node => this.node=node}>\n)\n}\n")])])]),a("p",[t._v("合并转发")]),t._v(" "),a("p",[t._v("高阶组件转发")]),t._v(" "),a("h3",{attrs:{id:"ref组件通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ref组件通信"}},[t._v("#")]),t._v(" ref组件通信")]),t._v(" "),a("p",[t._v("适用于不想通过父组件render改变props的方式触发子组件更新")]),t._v(" "),a("p",[t._v("函数组件forwardRef + useImperativeHandle")]),t._v(" "),a("h2",{attrs:{id:"context"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#context"}},[t._v("#")]),t._v(" Context")]),t._v(" "),a("p",[t._v("三种消费者")]),t._v(" "),a("p",[t._v("contextType")]),t._v(" "),a("p",[t._v("useContext")]),t._v(" "),a("p",[t._v("Consumer")]),t._v(" "),a("p",[t._v("动态context")]),t._v(" "),a("h2",{attrs:{id:"高阶组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#高阶组件"}},[t._v("#")]),t._v(" 高阶组件")]),t._v(" "),a("p",[a("strong",[t._v("属性代理型")])]),t._v(" "),a("p",[t._v("新组件代理旧组件的属性")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("render")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("OriginCpn "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("props"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),a("p",[a("strong",[t._v("反向继承型")])]),t._v(" "),a("p",[t._v("新组件继承旧组件")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")])]),t._v(" OriginCpn "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("hoc的三个作用")]),t._v(" "),a("p",[t._v("强化props")]),t._v(" "),a("p",[t._v("渲染劫持")]),t._v(" "),a("p",[t._v("动态加载")]),t._v(" "),a("h1",{attrs:{id:"优化篇"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优化篇"}},[t._v("#")]),t._v(" 优化篇")]),t._v(" "),a("h2",{attrs:{id:"渲染控制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#渲染控制"}},[t._v("#")]),t._v(" 渲染控制")]),t._v(" "),a("p",[t._v("react底层优化：任务优先级，异步调度，diff算法，时间分片")]),t._v(" "),a("p",[t._v("控制render")]),t._v(" "),a("p",[t._v("父组件层隔断：memo，useMemo缓存element")]),t._v(" "),a("p",[t._v("自身控制：shouldUpdate，PureComponent")]),t._v(" "),a("h2",{attrs:{id:"渲染调优"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#渲染调优"}},[t._v("#")]),t._v(" 渲染调优")]),t._v(" "),a("h2",{attrs:{id:"海量数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#海量数据"}},[t._v("#")]),t._v(" 海量数据")]),t._v(" "),a("h2",{attrs:{id:"细节处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#细节处理"}},[t._v("#")]),t._v(" 细节处理")])])}),[],!1,null,null,null);e.default=r.exports}}]);