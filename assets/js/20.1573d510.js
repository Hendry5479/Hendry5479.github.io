(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{402:function(_,v,p){"use strict";p.r(v);var t=p(45),s=Object(t.a)({},(function(){var _=this,v=_.$createElement,p=_._self._c||v;return p("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[p("p",[p("strong",[_._v("1、http、https")])]),_._v(" "),p("p",[_._v("http：超文本传输协议，80")]),_._v(" "),p("p",[_._v("http：HTTP加上SSL层建立安全通道，443")]),_._v(" "),p("p",[_._v("https更安全，需要ca证书费用高，相对低效")]),_._v(" "),p("p",[p("strong",[_._v("为什么说https更安全？")])]),_._v(" "),p("p",[p("strong",[_._v("https的工作原理")])]),_._v(" "),p("p",[_._v("1、客户端要求建立ssl连接")]),_._v(" "),p("p",[_._v("2、服务器返回证书，包含公钥")]),_._v(" "),p("p",[_._v("3、双方协商ssl安全等级，建立会话密钥")]),_._v(" "),p("p",[_._v("4、通过证书公钥加密会话密钥，客户端传送给服务器")]),_._v(" "),p("p",[_._v("5、服务器用私钥解开会话密钥")]),_._v(" "),p("p",[_._v("非对称加密和对称加密结合的方式")]),_._v(" "),p("p",[_._v("可能有中间人攻击，中间交换成自己的公钥，获取到双方的内容")]),_._v(" "),p("p",[_._v("证书校验公钥是否被篡改，证明证书有效，数字签名，ca提供的一种hash算法，秘钥加密签名，公钥解密签名，证明真伪")]),_._v(" "),p("p",[p("strong",[_._v("http版本")])]),_._v(" "),p("p",[_._v("1.0：短连接，断开重新握手；头部阻塞")]),_._v(" "),p("p",[_._v("1.1：长连接")]),_._v(" "),p("p",[_._v("2.0：多路复用，头部压缩，分帧传输，服务器主动推送")]),_._v(" "),p("p",[p("strong",[_._v("http缓存策略")])]),_._v(" "),p("p",[_._v("询问浏览器缓存")]),_._v(" "),p("p",[_._v("发送HTTP请求")]),_._v(" "),p("p",[_._v("存入浏览器缓存")]),_._v(" "),p("p",[_._v("检查是否有Cache-control 和 Expires：如果有，且未过期，则使用强缓存")]),_._v(" "),p("p",[_._v("否则使用协商缓存，发送请求，由浏览器决定资源是否可用")]),_._v(" "),p("p",[_._v("​\t对比Etag和")]),_._v(" "),p("p",[p("strong",[_._v("2、常见状态码")])]),_._v(" "),p("p",[_._v("1：收到请求")]),_._v(" "),p("p",[_._v("2：请求成功")]),_._v(" "),p("p",[_._v("​\t200：成功")]),_._v(" "),p("p",[_._v("3：重定向")]),_._v(" "),p("p",[_._v("​\t301：永久重定向，例如域名变更，浏览器会缓存，下次直接跳转")]),_._v(" "),p("p",[_._v("​\t302：临时重定向，不会缓存")]),_._v(" "),p("p",[_._v("​\t304：资源未修改，协商后使用缓存")]),_._v(" "),p("p",[_._v("4：客户端错误")]),_._v(" "),p("p",[_._v("​\t403：禁止")]),_._v(" "),p("p",[_._v("​\t404：未找到")]),_._v(" "),p("p",[_._v("5：服务端错误")]),_._v(" "),p("p",[_._v("​\t500：内部错误")]),_._v(" "),p("p",[_._v("​\t504：网关超时")]),_._v(" "),p("p",[p("strong",[_._v("TCP")])]),_._v(" "),p("p",[p("strong",[_._v("三次握手")])]),_._v(" "),p("p",[_._v("浏览器发送syn = 1, seq = x的数据包")]),_._v(" "),p("p",[_._v("服务器返回ack = 1, ack number = x + 1, syn = 1, seq = y")]),_._v(" "),p("p",[_._v("浏览器检查返回的seq是否正确，ack是否为1， 然后发送ack = 1, ack number = y + 1")]),_._v(" "),p("p",[p("strong",[_._v("为什么要三次握手？")])]),_._v(" "),p("p",[_._v("如果只有两次握手，服务器无法确定浏览器的接收能力，服务端无法确定浏览器是否获取到自己正确的序列号，可靠性无法保证")]),_._v(" "),p("p",[_._v("避免重复建立连接：")]),_._v(" "),p("p",[_._v("浏览器可能发送了两个不同序号的SYN包，三次握手的话，浏览器需要比对ACK和自己发送的SYN，旧的话发送RST，等待最新的返回才建立连接")]),_._v(" "),p("p",[p("strong",[_._v("第三次握手可以携带数据包吗？")])]),_._v(" "),p("p",[_._v("可以，因为客户端已经确定服务端的收发能力，可以携带数据包。")]),_._v(" "),p("p",[p("strong",[_._v("四次挥手")])]),_._v(" "),p("p",[_._v("客户端发送FIN=x给服务端，进入FIN-WAIT状态，停止发送")]),_._v(" "),p("p",[_._v("服务端返回ACK=x+1，进入CLOSE-WAIT状态，停止接收")]),_._v(" "),p("p",[_._v("服务端发送FIN=y，进入LAST-ACK")]),_._v(" "),p("p",[_._v("客户端发送ACK=y+1，进入TIME-WAIT，过一段时间后再进入CLOSED；服务端收到后进入CLOSED")]),_._v(" "),p("p",[p("strong",[_._v("为什么握手是三次，挥手是四次？")])]),_._v(" "),p("p",[_._v("因为握手时，服务端可以将ACK和SYN合并为一次发送。")]),_._v(" "),p("p",[_._v("而挥手时，客户端关闭发送后，服务端可能还要发送数据，所以不能将FIN包和ACK包一起发，所以分为四次")]),_._v(" "),p("p",[p("strong",[_._v("为什么TIME_WAIT 状态需要经过 2MSL 才能返回到 CLOSE 状态？")])]),_._v(" "),p("p",[_._v("MSL指的是报文在网络中最大生存时间")]),_._v(" "),p("p",[_._v("客户端发送的ACK包可能收不到，需要等一个来回确认。")]),_._v(" "),p("p",[_._v("滑动窗口")]),_._v(" "),p("p",[_._v("拥塞处理")]),_._v(" "),p("p",[_._v("缓存策略")]),_._v(" "),p("p",[_._v("强缓存和协商缓存")]),_._v(" "),p("p",[p("strong",[_._v("7、Node 事件循环 6阶段")])]),_._v(" "),p("p",[_._v("timer：到期settimeout回调")]),_._v(" "),p("p",[_._v("IO：到期回调")]),_._v(" "),p("p",[_._v("idle，prepare")]),_._v(" "),p("p",[_._v("poll：等回调；执行回调和定时器；有到期的settimeout回到timer；setimmediate则到check阶段")]),_._v(" "),p("p",[_._v("check：还行setimmediate")]),_._v(" "),p("p",[_._v("close callbacks：关闭")])])}),[],!1,null,null,null);v.default=s.exports}}]);