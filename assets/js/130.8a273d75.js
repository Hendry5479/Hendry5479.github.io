(window.webpackJsonp=window.webpackJsonp||[]).push([[130],{495:function(t,s,a){"use strict";a.r(s);var v=a(45),_=Object(v.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"辣鸡回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#辣鸡回收"}},[t._v("#")]),t._v(" 辣鸡回收")]),t._v(" "),a("p",[t._v("js引用类型保存在堆内存中，若没有了引用关系，则是不可达对象，需要被清理，否则会内存不足")]),t._v(" "),a("h2",{attrs:{id:"回收策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#回收策略"}},[t._v("#")]),t._v(" 回收策略")]),t._v(" "),a("h3",{attrs:{id:"标记清除"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#标记清除"}},[t._v("#")]),t._v(" 标记清除")]),t._v(" "),a("p",[t._v("​\t将活动对象打标记，清除阶段时销毁无标记对象")]),t._v(" "),a("p",[t._v("​\t引擎GC时从根节点（有多个）遍历内存中的对象打标记")]),t._v(" "),a("p",[t._v("​\t分配内存的三种策略：")]),t._v(" "),a("p",[t._v("​\t\tFirst-fit、Best-fit、Worst-fit")]),t._v(" "),a("p",[t._v("​\t"),a("strong",[t._v("优点")]),t._v("：简单")]),t._v(" "),a("p",[t._v("​\t"),a("strong",[t._v("缺点")]),t._v("：有内存碎片、慢")]),t._v(" "),a("p",[t._v("​\t"),a("strong",[t._v("标记整理")]),t._v("法：标记结束后将活动对象移动到一端，然后清理")]),t._v(" "),a("h3",{attrs:{id:"引用计数法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#引用计数法"}},[t._v("#")]),t._v(" 引用计数法")]),t._v(" "),a("p",[t._v("​\t被引用、赋给另一个变量时+1，被覆盖则-1；0则销毁")]),t._v(" "),a("p",[t._v("​\t缺点：1、无法解决循环引用的问题；2、计数器占用内存大")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("test")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("A")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("B")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  \n  "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("A")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("b "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("B")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("B")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("A")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("A和B相互引用，则引用数量都是2，不被清理")]),t._v(" "),a("p",[t._v("标记清除策略的话，在函数结束后，两个对象都不在作用域中，都被清除掉。")]),t._v(" "),a("h2",{attrs:{id:"v8的gc优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v8的gc优化"}},[t._v("#")]),t._v(" V8的GC优化")]),t._v(" "),a("p",[t._v("基于标记清除的分代式GC")]),t._v(" "),a("p",[t._v("新生代的特点是存活时间短、比较小")]),t._v(" "),a("p",[t._v("因此将内存区域区分为新老生代，使用不同频率的GC，优化性能")]),t._v(" "),a("p",[a("strong",[t._v("新生代的GC")])]),t._v(" "),a("p",[t._v("​\t将新生代的堆内存分为使用区和空闲区，标记一次后，将活动对象转去空闲区，然后清空使用区，反转")]),t._v(" "),a("p",[t._v("​\t如果多次GC仍然存活，或者对象比较大，则转去老生代")]),t._v(" "),a("p",[t._v("老生代GC")]),t._v(" "),a("p",[t._v("​\t不用复制法，直接使用标记清除整理法")]),t._v(" "),a("h2",{attrs:{id:"并行回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#并行回收"}},[t._v("#")]),t._v(" 并行回收")]),t._v(" "),a("p",[t._v("Stop-The-World：全停顿，JS脚本等待GC后恢复运行的行为")]),t._v(" "),a("p",[t._v("并行回收则是在GC时引入辅助线程提高效率")]),t._v(" "),a("p",[t._v("依然会停顿，但是会减少耗时，而且不用考虑引用关系的改变")]),t._v(" "),a("p",[a("strong",[t._v("新生代GC就采用并行回收")])]),t._v(" "),a("h2",{attrs:{id:"增量标记和懒清理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#增量标记和懒清理"}},[t._v("#")]),t._v(" 增量标记和懒清理")]),t._v(" "),a("p",[t._v("并行回收依然全停顿，对于老生代而言耗时依然很久")]),t._v(" "),a("h3",{attrs:{id:"增量标记-将gc变成可中断"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#增量标记-将gc变成可中断"}},[t._v("#")]),t._v(" 增量标记：将GC变成可中断")]),t._v(" "),a("p",[a("strong",[t._v("中断后恢复的方法：")])]),t._v(" "),a("p",[a("strong",[t._v("三色标记法：")])]),t._v(" "),a("p",[t._v("​\t白色：无活动；灰色：自身标记、成员未标记；黑色：已全标记")]),t._v(" "),a("p",[t._v("​\t每次中断恢复时就从灰色标记开始执行")]),t._v(" "),a("p",[a("strong",[t._v("写屏障：")])]),t._v(" "),a("p",[t._v("​\t白色对象被引用后还未标记，可能在下一轮被回收的问题")]),t._v(" "),a("p",[t._v("​\t强制让被黑色引用的白色变灰色")]),t._v(" "),a("h3",{attrs:{id:"懒清理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#懒清理"}},[t._v("#")]),t._v(" 懒清理")]),t._v(" "),a("p",[t._v("如果内存足够执行代码，就延迟清理，也不需要全部清理，可以慢慢清")]),t._v(" "),a("p",[t._v("增量标记和懒清理减少了STW的时间，但是没有减少主线程的总暂停时间")]),t._v(" "),a("h2",{attrs:{id:"并发回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#并发回收"}},[t._v("#")]),t._v(" 并发回收")]),t._v(" "),a("p",[t._v("用辅助线程GC，主线程不挂起")]),t._v(" "),a("p",[t._v("需要有额外的读写锁机制控制引用关系的变化")]),t._v(" "),a("p",[a("strong",[t._v("老生代主要使用并发标记、并发清理，同时用增量的方式分批执行")])])])}),[],!1,null,null,null);s.default=_.exports}}]);