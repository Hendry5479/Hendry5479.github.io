(window.webpackJsonp=window.webpackJsonp||[]).push([[92],{460:function(e,a,r){"use strict";r.r(a);var n=r(45),p=Object(n.a)({},(function(){var e=this,a=e.$createElement,r=e._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h3",{attrs:{id:"问题一览"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#问题一览"}},[e._v("#")]),e._v(" 问题一览")]),e._v(" "),r("p",[e._v("webpack与grunt、gulp的不同？\n与webpack类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用webpack？\n有哪些常见的Loader？他们是解决什么问题的？\n有哪些常见的Plugin？他们是解决什么问题的？\nLoader和Plugin的不同？\nwebpack的构建流程是什么?从读取配置到输出文件这个过程尽量说全\n是否写过Loader和Plugin？描述一下编写loader或plugin的思路？\nwebpack的热更新是如何做到的？说明其原理？\n如何利用webpack来优化前端性能？（提高性能和体验）\n如何提高webpack的构建速度？\n怎么配置单页应用？怎么配置多页应用？\nnpm打包时需要注意哪些？如何利用webpack来更好的构建？\n如何在vue项目中实现按需加载？")]),e._v(" "),r("h2",{attrs:{id:"问题解答"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#问题解答"}},[e._v("#")]),e._v(" 问题解答")]),e._v(" "),r("h3",{attrs:{id:"_1-webpack与grunt、gulp的不同"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-webpack与grunt、gulp的不同"}},[e._v("#")]),e._v(" 1. webpack与grunt、gulp的不同？")]),e._v(" "),r("p",[e._v("轻量化的任务会用gulp来处理，比如单独打包CSS文件")]),e._v(" "),r("p",[r("strong",[e._v("grunt和gulp是基于任务和流（Task、Stream）的")]),e._v("\n类似jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个web的构建流程。")]),e._v(" "),r("p",[r("strong",[e._v("webpack是基于入口")]),e._v("\nwebpack会解析入口所需要加载的所有资源文件，用不同的Loader处理文件，用Plugin来扩展功能")]),e._v(" "),r("p",[e._v("总结：\n从构建思路来说\ngulp和grunt将构建过程拆分成多个"),r("code",[e._v("Task")]),e._v("，并合理控制所有"),r("code",[e._v("Task")]),e._v("的调用关系\nwebpack需要入口，需要清楚对于不同的资源应该使用什么Loader做解析")]),e._v(" "),r("p",[e._v("gulp更像后端开发者的思路，需要对于整个流程了如指掌\nwebpack更倾向于前端开发者的思路")]),e._v(" "),r("h3",{attrs:{id:"_2-与webpack类似的工具还有哪些-谈谈你为什么最终选择-或放弃-使用webpack"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-与webpack类似的工具还有哪些-谈谈你为什么最终选择-或放弃-使用webpack"}},[e._v("#")]),e._v(" 2. 与webpack类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用webpack？")]),e._v(" "),r("p",[e._v("同样是基于入口的打包工具还有以下几个主流的：\nwebpack\nrollup")]),e._v(" "),r("p",[e._v("从应用场景上来看：\nwebpack适用于大型复杂的前端站点构建\nrollup适用于基础库的打包，如vue、react")]),e._v(" "),r("h3",{attrs:{id:"_3-有哪些常见的loader-他们是解决什么问题的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-有哪些常见的loader-他们是解决什么问题的"}},[e._v("#")]),e._v(" 3.有哪些常见的Loader？他们是解决什么问题的？")]),e._v(" "),r("p",[e._v("file-loader：把文件输出到一个文件夹中，在代码中通过URL引用输出的文件\nurl-loader：和 file-loader 类似，把文件内容注入到代码中去\nsource-map-loader：加载额外的 Source Map 文件，以方便断点调试\nimage-loader：加载并且压缩图片文件\nbabel-loader：把 ES6 转换成 ES5\ncss-loader：加载 CSS，支持模块化、压缩、文件导入等特性\nstyle-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作加载 CSS\neslint-loader：通过 ESLint 检查 JavaScript 代码")]),e._v(" "),r("h3",{attrs:{id:"_4-有哪些常见的plugin-他们是解决什么问题的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-有哪些常见的plugin-他们是解决什么问题的"}},[e._v("#")]),e._v(" 4.有哪些常见的Plugin？他们是解决什么问题的？")]),e._v(" "),r("p",[e._v("define-plugin：定义环境变量\ncommons-chunk-plugin：提取公共代码\nuglifyjs-webpack-plugin：通过UglifyES压缩ES6代码")]),e._v(" "),r("h3",{attrs:{id:"_5-loader和plugin的不同"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-loader和plugin的不同"}},[e._v("#")]),e._v(" 5.Loader和Plugin的不同？")]),e._v(" "),r("p",[r("strong",[e._v("不同的作用")]),e._v("\nLoader"),r("strong",[e._v("让webpack拥有加载解析非js文件的能力")]),e._v("\nWebpack将文件视为模块，webpack原生只能解析js文件，将其他文件打包就会用到loader。")]),e._v(" "),r("p",[e._v("Plugin"),r("strong",[e._v("扩展webpack的功能")]),e._v("\n在 Webpack 生命周期中会广播出许多事件，Plugin 可以监听事件")]),e._v(" "),r("p",[r("strong",[e._v("不同的用法")]),e._v("\nLoader在module.rules中配置，作为解析规则而存在。 类型为数组，每一项都是Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options）")]),e._v(" "),r("p",[e._v("Plugin在plugins中单独配置。 类型为数组，每一项是一个plugin实例，参数通过构造函数传入")]),e._v(" "),r("h3",{attrs:{id:"_6-webpack的构建流程是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-webpack的构建流程是什么"}},[e._v("#")]),e._v(" 6.webpack的构建流程是什么?")]),e._v(" "),r("p",[e._v("初始化参数、初始化编译对象加载插件开始编译、确定入口文件、编译模块递归调用Loader、\n输出资源、输出文件\nWebpack 的运行流程是串行的过程，从启动到结束会依次执行以下")]),e._v(" "),r("p",[r("strong",[e._v("初始化参数")]),e._v("：从配置文件和 Shell 语句读取参数")]),e._v(" "),r("p",[r("strong",[e._v("开始编译")]),e._v("：用得到的参数初始化 Compiler 对象，加载插件，执行对象的 run 方法开始编译；")]),e._v(" "),r("p",[r("strong",[e._v("确定入口")]),e._v("：根据配置中的 entry 找出所有的入口文件；")]),e._v(" "),r("p",[r("strong",[e._v("编译模块")]),e._v("：从入口文件出发，调用Loader 对模块进行翻译，直到所有入口依赖的文件都经过了本步骤的处理；")]),e._v(" "),r("p",[r("strong",[e._v("完成模块编译")]),e._v("：得到每个模块被翻译后的最终内容以及依赖关系；")]),e._v(" "),r("p",[r("strong",[e._v("输出资源")]),e._v("：根据入口和模块的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成单独的文件加入到输出列表")]),e._v(" "),r("p",[r("strong",[e._v("输出完成")]),e._v("：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。")]),e._v(" "),r("p",[e._v("在以上过程中，Webpack 广播出事件，插件在监听到感兴趣的事件后会执行逻辑，改变 Webpack 的运行结果。")]),e._v(" "),r("h3",{attrs:{id:"_7-是否写过loader和plugin-描述一下编写loader或plugin的思路"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7-是否写过loader和plugin-描述一下编写loader或plugin的思路"}},[e._v("#")]),e._v(" 7.是否写过Loader和Plugin？描述一下编写loader或plugin的思路？")]),e._v(" "),r("p",[e._v('Loader像一个"翻译官"，把读到的源文件内容转义成新的文件内容，并且每个Loader通过链式操作，将源文件一步步翻译成想要的样子。')]),e._v(" "),r("p",[e._v('编写Loader时要遵循单一原则，每个Loader只做一种"转义"工作。 每个Loader的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用this.callback()方法，将内容返回给webpack。 还可以通过 this.async()生成一个callback函数，再用这个callback将处理后的内容输出出去。 此外webpack还为开发者准备了开发loader的工具函数集——loader-utils。')]),e._v(" "),r("p",[e._v("相对于Loader而言，Plugin的编写就灵活了许多。 webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。")]),e._v(" "),r("h3",{attrs:{id:"_8-webpack的热更新是如何做到的-说明其原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-webpack的热更新是如何做到的-说明其原理"}},[e._v("#")]),e._v(" 8.webpack的热更新是如何做到的？说明其原理？")]),e._v(" "),r("p",[e._v("webpack的热更新又称热替换（Hot Module Replacement），缩写为HMR。\n不刷新浏览器而替换模块")]),e._v(" "),r("p",[r("strong",[e._v("1.Webpack监听文件变化，重新编译打包，存至内存\n2.webpack-server与webpack交互\n3.server监控文件变化，变化则通知浏览器刷新\n4.server与browser建立长连接，传递静态文件变化信息\n5.client根据变化判断是浏览器刷新还是热更新\n6.热更新的话，热更新的对象接收server hash，发送Ajax请求，获取更新列表，再发请求获取更新代码\n7.热更新插件比对新旧模块，进行热更新，包括相关依赖")])]),e._v(" "),r("p",[e._v("原理：\n首先要知道server端和client端都做了处理工作\n"),r("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Hendry5479/learn-react/img/20201230082904.png",alt:""}})]),e._v(" "),r("p",[e._v("HotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到上一步传递给他的新模块的 hash 值，它通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回一个 json，该 json 包含了所有要更新的模块的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码。这就是上图中 7、8、9 步骤。\n而第 10 步是决定 HMR 成功与否的关键步骤，在该步骤中，HotModulePlugin 将会对新旧模块进行对比，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用。")]),e._v(" "),r("p",[e._v("最后一步，当 HMR 失败后，回退到 live reload 操作，也就是进行浏览器刷新来获取最新打包代码。")]),e._v(" "),r("p",[e._v("第一步，在 webpack 的 watch 模式下，webpack 监听到文件变化对模块重新编译打包，并将打包后的代码通过js对象保存在内存中")]),e._v(" "),r("p",[e._v("第二步是 webpack-dev-server 和 webpack 的接口交互，主要是 dev-server 的中间件 webpack-dev-middleware 和 webpack 的交互，webpack-dev-middleware 调用 webpack API对代码变化进行监控，并且告诉 webpack，将代码打包到内存中")]),e._v(" "),r("p",[e._v("第三步是 webpack-dev-server 对文件变化的监控，这一步不同于第一步，并不是监控代码变化重新打包。当我们在配置文件中配置了devServer.watchContentBase 为 true 的时候，Server 会监听静态文件变化，变化后会通知浏览器对应用进行 live reload。注意，这儿是浏览器刷新，和 HMR 是两个概念。")]),e._v(" "),r("p",[e._v("第四步也是 webpack-dev-server 代码的工作，通过 sockjs在建立websocket 长连接，将 webpack 编译打包的各个阶段的状态信息告知浏览器，同时也包括第三步中 Server 监听静态文件变化的信息。浏览器端根据socket 消息进行操作。服务端传递的最主要信息还是新模块的 hash 值，后面的步骤根据这hash 值进行模块热替换")]),e._v(" "),r("p",[e._v("webpack-dev-server/client 端并不能够请求更新的代码，也不会执行热更模块操作，而把这些工作又交回给了 webpack，webpack/hot/dev-server 的工作就是根据 webpack-dev-server/client 传给它的信息以及 dev-server 的配置决定是刷新浏览器呢还是进行模块热更新。当然如果仅仅是刷新浏览器，也就没有后面那些步骤了。")]),e._v(" "),r("p",[e._v("HotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到上一步传递给他的新模块的 hash 值，它通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回一个 json，该 json 包含了所有要更新的模块的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码。这就是上图中 7、8、9 步骤。\n而第 10 步是决定 HMR 成功与否的关键步骤，在该步骤中，HotModulePlugin 将会对新旧模块进行对比，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用。")]),e._v(" "),r("p",[e._v("最后一步，当 HMR 失败后，回退到 live reload 操作，也就是进行浏览器刷新来获取最新打包代码。")]),e._v(" "),r("h3",{attrs:{id:"_9-如何利用webpack来优化前端性能-提高性能和体验"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-如何利用webpack来优化前端性能-提高性能和体验"}},[e._v("#")]),e._v(" 9.如何利用webpack来优化前端性能？（提高性能和体验）")]),e._v(" "),r("p",[e._v("用webpack优化前端性能是指优化webpack的输出结果，让打包结果在浏览器运行快速高效\n"),r("strong",[e._v("压缩代码")]),e._v("：利用webpack的UglifyJsPlugin和ParallelUglifyPlugin压缩JS文件， 利用cssnano（css-loader?minimize）压缩css\n"),r("strong",[e._v("利用CDN加速")]),e._v("。将静态资源路径修改为CDN对应的路径。可以利用webpack对于output参数和各loader的publicPath参数来修改资源路径\n"),r("strong",[e._v("删除死代码")]),e._v("（Tree Shaking）。将代码中不会走到的片段删除掉。可以通过在启动webpack时追加参数--optimize-minimize来实现\n"),r("strong",[e._v("提取公共代码")])]),e._v(" "),r("h3",{attrs:{id:"_10-如何提高webpack的构建速度"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_10-如何提高webpack的构建速度"}},[e._v("#")]),e._v(" 10.如何提高webpack的构建速度？")]),e._v(" "),r("p",[e._v("多入口情况下，使用CommonsChunkPlugin来提取公共代码\n通过externals配置来提取常用库\n利用DllPlugin和DllReferencePlugin预编译资源模块 通过DllPlugin对npm包预编译，通过DllReferencePlugin将预编译的模块加载进来。\n使用Happypack 实现多线程加速编译\n使用webpack-uglify-parallel来提升uglifyPlugin的压缩速度\n使用Tree-shaking和Scope Hoisting来剔除多余代码")]),e._v(" "),r("h3",{attrs:{id:"_11-怎么配置单页应用-怎么配置多页应用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_11-怎么配置单页应用-怎么配置多页应用"}},[e._v("#")]),e._v(" 11.怎么配置单页应用？怎么配置多页应用？")]),e._v(" "),r("p",[e._v("单页应用可以理解为webpack的标准模式，直接在entry中指定单页应用的入口即可\n多页应用的话使用webpack的 AutoWebPlugin完成构建，前提是项目的目录结构遵守规范。\n多页应用中要注意的是：\n抽离公共代码避免重复加载\n入口配置足够灵活，避免每次添加新页面还需要修改构建配置")]),e._v(" "),r("h3",{attrs:{id:"_12-npm打包时需要注意哪些-如何利用webpack来更好的构建"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_12-npm打包时需要注意哪些-如何利用webpack来更好的构建"}},[e._v("#")]),e._v(" 12.npm打包时需要注意哪些？如何利用webpack来更好的构建？")]),e._v(" "),r("p",[e._v("Npm是最大的 JavaScript 模块仓库")]),e._v(" "),r("p",[e._v("NPM模块需要注意以下问题：\n要支持CommonJS模块化规范，打包后的最后结果也遵守该规则\n打包的结果应该是ES5编写的。如果ES5是经过转换的，请最好连同SourceMap一同上传\n尽量小\n发布的模块不能将依赖的模块也一同打包，应该让用户自行安装。避免重复打包\nUI组件类的模块应该将依赖.css文件包含在模块里")]),e._v(" "),r("p",[e._v("基于以上需要注意的问题，对于webpack配置做以下扩展和优化：\nCommonJS模块化规范的解决方案： 设置output.libraryTarget='commonjs2'使输出的代码符合CommonJS2 模块化规范，以供给其它模块导入使用\n输出ES5代码的解决方案：使用babel-loader把 ES6 代码转换成 ES5 的代码。再通过开启devtool: 'source-map'输出SourceMap以发布调试。\nNpm包大小尽量小的解决方案：Babel 在把 ES6 代码转换成 ES5 代码时会注入一些辅助函数，最终导致每个输出的文件中都包含这段辅助函数的代码，造成了代码的冗余。解决方法是修改.babelrc文件，为其加入transform-runtime插件\n不能将依赖模块打包到NPM模块中的解决方案：使用externals配置项来告诉webpack哪些模块不需要打包。\n对于依赖的资源文件打包的解决方案：通过css-loader和extract-text-webpack-plugin来实现，配置如下：")]),e._v(" "),r("h3",{attrs:{id:"_13-如何在vue项目中实现按需加载"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_13-如何在vue项目中实现按需加载"}},[e._v("#")]),e._v(" 13.如何在vue项目中实现按需加载？")]),e._v(" "),r("p",[e._v("Vue UI组件库的按需加载 为了快速开发前端项目，经常会引入现成的UI组件库如ElementUI、iView等，但是他们的体积和他们所提供的功能一样，是很庞大的。 而通常情况下，我们仅仅需要少量的几个组件就足够了，但是我们却将庞大的组件库打包到我们的源码中，造成了不必要的开销。")]),e._v(" "),r("p",[e._v("不过很多组件库已经提供了现成的解决方案，如Element出品的babel-plugin-component和AntDesign出品的babel-plugin-import 安装以上插件后，在.babelrc配置中或babel-loader的参数中进行设置，即可实现组件按需加载了。")]),e._v(" "),r("p",[e._v("单页应用的按需加载 现在很多前端项目都是通过单页应用的方式开发的，但是随着业务的不断扩展，会面临一个严峻的问题——首次加载的代码量会越来越多，影响用户的体验。")]),e._v(" "),r("p",[e._v("通过import("),r("em",[e._v(")语句来控制加载时机，webpack内置了对于import(")]),e._v(")的解析，会将import("),r("em",[e._v(")中引入的模块作为一个新的入口在生成一个chunk。 当代码执行到import(")]),e._v(")语句时，会去加载Chunk对应生成的文件。import()会返回一个Promise对象，所以为了让浏览器支持，需要事先注入Promise polyfill")]),e._v(" "),r("p",[e._v("参考文章\n关于 webpack 的面试题有哪些？\n前端面试之webpack面试常见问题\n《深入浅出webpack》电子版\nwebpack 构建性能优化策略小结")])])}),[],!1,null,null,null);a.default=p.exports}}]);