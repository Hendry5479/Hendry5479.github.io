(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{420:function(t,s,a){"use strict";a.r(s);var e=a(45),n=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"渲染控制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#渲染控制"}},[t._v("#")]),t._v(" 渲染控制")]),t._v(" "),a("h2",{attrs:{id:"渲染的理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#渲染的理解"}},[t._v("#")]),t._v(" 渲染的理解")]),t._v(" "),a("p",[t._v("事实上，从调度更新任务到调和 fiber，再到浏览器渲染真实 DOM，每一个环节都是渲染的一部分")]),t._v(" "),a("p",[t._v("React 在底层已经处理了大部分优化细节，包括设立任务优先级、异步调度、diff算法、时间分片")]),t._v(" "),a("h3",{attrs:{id:"render阶段的作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#render阶段的作用"}},[t._v("#")]),t._v(" render阶段的作用")]),t._v(" "),a("p",[t._v("render函数：根据更新产生的新状态，生成新element，并替换。element产生新的props")]),t._v(" "),a("p",[t._v("调和：react调和产生children，将子代element变成fiber；将props变成pendingProps，更新完毕。")]),t._v(" "),a("p",[t._v("children是组件的话将重复操作")]),t._v(" "),a("h2",{attrs:{id:"控制render"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#控制render"}},[t._v("#")]),t._v(" 控制render")]),t._v(" "),a("ul",[a("li",[t._v("父组件隔断子组件渲染，如 "),a("strong",[t._v("memo")]),t._v("，"),a("strong",[t._v("缓存 element 对象")])]),t._v(" "),a("li",[t._v("组件自身控制render ，比如："),a("strong",[t._v("PureComponent")]),t._v(" ，"),a("strong",[t._v("shouldComponentUpdate")])])]),t._v(" "),a("h3",{attrs:{id:"_1-usememo缓存react-element"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-usememo缓存react-element"}},[t._v("#")]),t._v(" 1.useMemo缓存React.element")]),t._v(" "),a("p",[t._v("使用场景：父组件 render ，子组件没有必要跟着父组件一起 render")]),t._v(" "),a("p",[t._v("用 React.useMemo 缓存element")]),t._v(" "),a("p",[a("strong",[t._v("useMemo 用法：")])]),t._v(" "),a("p",[a("code",[t._v("const cacheSomething = useMemo(create,deps)")])]),t._v(" "),a("p",[a("code",[t._v("{ useMemo(()=> <Children number={numberA} />, [ numberA ]) }")])]),t._v(" "),a("p",[a("strong",[t._v("useMemo原理：")])]),t._v(" "),a("p",[t._v("useMemo 会记录上一次执行 create 的返回值，保存在函数组件的 "),a("strong",[t._v("fiber")]),t._v(" 对象上")]),t._v(" "),a("p",[t._v("只要组件不销毁，缓存值就一直存在，deps 改变就会重新执行 create")]),t._v(" "),a("p",[a("strong",[t._v("原理揭秘")])]),t._v(" "),a("p",[t._v("render时createElement产生pendingProps，reconcile时对比pending props和old props，相同则不更新")]),t._v(" "),a("p",[t._v("将element缓存了，props指向相同的内存空间，跳过更新")]),t._v(" "),a("h3",{attrs:{id:"_2-purecomponent"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-purecomponent"}},[t._v("#")]),t._v(" 2.PureComponent")]),t._v(" "),a("p",[t._v("纯组件是一种发自组件本身的渲染优化策略，其渲染规则就是"),a("strong",[t._v("浅比较 state 和 props 是否相等")])]),t._v(" "),a("h4",{attrs:{id:"purecomponent-原理及其浅比较原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#purecomponent-原理及其浅比较原则"}},[t._v("#")]),t._v(" PureComponent 原理及其浅比较原则")]),t._v(" "),a("p",[t._v("PureComponent 继承的组件，原型链上会有 isPureReactComponent 属性")]),t._v(" "),a("p",[a("code",[t._v("react/src/ReactBaseClasses.js")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* pureComponentPrototype 纯组件构造函数的 prototype 对象，绑定isPureReactComponent 属性。 */")]),t._v("\npureComponentPrototype"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("isPureReactComponent "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("这个属性在更新组件 "),a("code",[t._v("updateClassInstance")]),t._v(" 方法中使用的")]),t._v(" "),a("p",[t._v("在 "),a("code",[t._v("updateClassInstance")]),t._v(" 有一个负责检查是否更新的函数 "),a("code",[t._v("checkShouldComponentUpdate")])]),t._v(" "),a("blockquote",[a("p",[t._v("react/react-reconciler/ReactFiberClassComponent.js")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("checkShouldComponentUpdate")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n     "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typeof")]),t._v(" instance"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("shouldComponentUpdate "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'function'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n         "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" instance"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("shouldComponentUpdate")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("newProps"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("newState"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("nextContext"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* shouldComponentUpdate 逻辑 */")]),t._v("\n     "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" \n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ctor"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" ctor"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("isPureReactComponent"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 若是纯函数，则浅比较props和state")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("shallowEqual")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("oldProps"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" newProps"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("shallowEqual")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("oldState"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" newState"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("shouldComponentUpdate 的权重，会大于 PureComponent")]),t._v(" "),a("p",[t._v("shallowEqual：")]),t._v(" "),a("p",[t._v("比较两个值是否相等")]),t._v(" "),a("p",[t._v("如果有非obj或为null，返回false，更新")]),t._v(" "),a("p",[t._v("通过Object.keys将key变成数组，判断长度，长度不相等，返回false，更新")]),t._v(" "),a("p",[t._v("遍历，发现item不相等，返回false，更新")]),t._v(" "),a("h4",{attrs:{id:"purecomponent注意事项"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#purecomponent注意事项"}},[t._v("#")]),t._v(" PureComponent注意事项")]),t._v(" "),a("h5",{attrs:{id:"禁用箭头函数-否则纯组件失效。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#禁用箭头函数-否则纯组件失效。"}},[t._v("#")]),t._v(" 禁用箭头函数，否则纯组件失效。")]),t._v(" "),a("p",[t._v("因为父组件render时，箭头函数会重新定义。PureComponent会始终判断props不相等")]),t._v(" "),a("h5",{attrs:{id:"父组件是函数组件时-绑定函数要用usecallback或者usememo"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#父组件是函数组件时-绑定函数要用usecallback或者usememo"}},[t._v("#")]),t._v(" 父组件是函数组件时，绑定函数要用useCallback或者useMemo")]),t._v(" "),a("p",[t._v("函数组件每次执行都会声明新函数，纯组件会失效")]),t._v(" "),a("p",[t._v("useCallback 首选，这个 hooks 初衷就是为了解决这种情况的")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Child")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("React"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("PureComponent")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" div\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("default")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" func "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("useCallback")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Child func"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("func"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[a("code",[t._v("useCallback")]),t._v(" 和 "),a("code",[t._v("useMemo")]),t._v(" 有什么区别？")]),t._v(" "),a("p",[t._v("useCallback的第一个参数是缓存的内容")]),t._v(" "),a("p",[t._v("useMemo需要执行第一个函数，返回值才是缓存的内容。更像是缓存了一段逻辑的执行结果")]),t._v(" "),a("h3",{attrs:{id:"_3-shouldcomponentupdate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-shouldcomponentupdate"}},[t._v("#")]),t._v(" 3.shouldComponentUpdate")]),t._v(" "),a("p",[t._v("React提供的一种更灵活的自定义渲染方案")]),t._v(" "),a("p",[t._v("shouldComponentUpdate 可以根据传入的新的 props 和 state ，或者 newContext 来确定是否更新组件")]),t._v(" "),a("h4",{attrs:{id:"immutable-js"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#immutable-js"}},[t._v("#")]),t._v(" immutable.js")]),t._v(" "),a("p",[t._v("但是如果有子组件的props是引用数据类型，且结构未知，如何解决新老属性对比问题？使用 "),a("code",[t._v("immutable.js")])]),t._v(" "),a("p",[t._v("对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象。通过对比Immutable证明状态是否改变")]),t._v(" "),a("h3",{attrs:{id:"_4-react-memo"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-react-memo"}},[t._v("#")]),t._v(" 4.React.memo")]),t._v(" "),a("p",[a("code",[t._v("React.memo(Component,compare)")])]),t._v(" "),a("p",[t._v("作为一种容器化的控制渲染方案，可以对比 props 变化来决定是否渲染组件")]),t._v(" "),a("p",[t._v("memo特点")]),t._v(" "),a("ul",[a("li",[t._v("第一个参数 Component 原始组件本身，第二个参数 compare 是一个函数，返回 true 组件不渲染。")]),t._v(" "),a("li",[t._v("当compare 不存在时，会用"),a("strong",[t._v("浅比较原则")]),t._v("处理 props ，相当于仅比较 props 版本的 pureComponent")]),t._v(" "),a("li",[t._v("memo 同样适合类组件和函数组件。")])]),t._v(" "),a("p",[t._v("被 memo 包裹的组件，element 会被打成 "),a("code",[t._v("REACT_MEMO_TYPE")]),t._v(" 类型的 element 标签")]),t._v(" "),a("p",[t._v("在 element 变成 fiber 的时候， fiber 会被标记成 "),a("strong",[t._v("MemoComponent")]),t._v(" 的类型")]),t._v(" "),a("blockquote",[a("p",[t._v("react/src/ReactMemo.js")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("memo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("type"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("compare")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" elementType "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    $$"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typeof")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("REACT_MEMO_TYPE")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" \n    type"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 我们的组件")]),t._v("\n    compare"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" compare "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("undefined")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" compare"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//第二个参数，一个函数用于判断prop，控制更新方向。")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" elementType\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("blockquote",[a("p",[t._v("react-reconciler/src/ReactFiber.js")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("case")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("REACT_MEMO_TYPE")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n  fiberTag "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" MemoComponent"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("React 对 MemoComponent 类型的 fiber 有单独的更新处理逻辑 updateMemoComponent")]),t._v(" "),a("blockquote",[a("p",[t._v("react-reconciler/src/ReactFiberBeginWork.js")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("updateMemoComponent")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("updateExpirationTime "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" renderExpirationTime"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n         "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" compare "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Component"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("compare"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n         compare "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" compare "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!==")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v(" compare "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" shallowEqual "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//如果 memo 有第二个参数，则用二个参数判定，没有则浅比较props是否相等。")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("compare")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("prevProps"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" nextProps"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" current"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("ref "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" workInProgress"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("ref"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("bailoutOnAlreadyFinishedWork")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("current"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("workInProgress"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("renderExpirationTime"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//已经完成工作，停止向下调和节点。")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 返回将要更新组件,memo包装的组件对应的fiber，继续向下调和更新。")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("memo 主要逻辑是")]),t._v(" "),a("ul",[a("li",[t._v("通过 memo 第二个参数，判断是否更新，如果没有第二个参数，以浅比较 props 为 diff 规则。如果相等，当前 fiber 完成工作，停止向下调和节点，被包裹的组件不更新。")]),t._v(" "),a("li",[t._v("memo 可以理解为包了一层的高阶组件，它的阻断更新机制，是通过控制下一级 children ，也就是 memo 包装的组件，是否继续调和渲染，来达到目的")]),t._v(" "),a("li")]),t._v(" "),a("h3",{attrs:{id:"_5-打破渲染限制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-打破渲染限制"}},[t._v("#")]),t._v(" 5.打破渲染限制")]),t._v(" "),a("h4",{attrs:{id:"_1-forceupdate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-forceupdate"}},[t._v("#")]),t._v(" 1. forceupdate")]),t._v(" "),a("p",[t._v("类组件调用forceUpdate会跳过PureComponent和shouldComponentUpdate")]),t._v(" "),a("p",[t._v("因为调用时会开启一个hasForceUpdate开关")]),t._v(" "),a("h4",{attrs:{id:"_2-context穿透"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-context穿透"}},[t._v("#")]),t._v(" 2.context穿透")]),t._v(" "),a("p",[t._v("上述的方式都不能改变context改变带来的渲染穿透")]),t._v(" "),a("p",[t._v("选择了消费context，就要承受context的改变带来的更新")]),t._v(" "),a("h3",{attrs:{id:"_6-渲染控制流程图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-渲染控制流程图"}},[t._v("#")]),t._v(" 6.渲染控制流程图")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3df03000a39549bead3c84750c62576c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp",alt:"5.jpg"}})]),t._v(" "),a("h2",{attrs:{id:"对render的思考"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对render的思考"}},[t._v("#")]),t._v(" 对render的思考")]),t._v(" "),a("h3",{attrs:{id:"_1-无须过分在乎-react-没有必要的渲染"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-无须过分在乎-react-没有必要的渲染"}},[t._v("#")]),t._v(" 1.无须过分在乎 React 没有必要的渲染")]),t._v(" "),a("p",[t._v("js 代码远快于浏览器的 Rendering 和 Painting，更何况 React 还提供了 diff 算法等手段")]),t._v(" "),a("h3",{attrs:{id:"_2-什么时候需要注意渲染节流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-什么时候需要注意渲染节流"}},[t._v("#")]),t._v(" 2.什么时候需要注意渲染节流")]),t._v(" "),a("ul",[a("li",[t._v("数据可视化的模块组件，更新伴随大量diff ，有必要采取 memo ，shouldComponentUpdate 等")]),t._v(" "),a("li",[t._v("React 一般采用受控组件去管理表单数据层，表单数据层托管于 props 或是 state ，用户操作频繁，页面高频率 render")]),t._v(" "),a("li",[t._v("越是靠近 app root 根组件越值得注意，根组件渲染会波及到整个组件树重新 render ，子组件 render ，一是浪费性能，二是可能执行 useEffect ，componentWillReceiveProps 等钩子，造成意想不到的情况发生")])]),t._v(" "),a("h3",{attrs:{id:"_3-一些开发中的细节"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-一些开发中的细节"}},[t._v("#")]),t._v(" 3.一些开发中的细节")]),t._v(" "),a("p",[t._v("表单控件最好单独抽离，独自管理自己的数据层，这样可以让 state 改变，波及的范围更小")]),t._v(" "),a("p",[t._v("更精致化渲染可以配合 immutable.js")]),t._v(" "),a("p",[t._v("组件颗粒化，配合 memo 等 api ，可以制定私有化的渲染空间")]),t._v(" "),a("h1",{attrs:{id:"渲染调优"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#渲染调优"}},[t._v("#")]),t._v(" 渲染调优")]),t._v(" "),a("h2",{attrs:{id:"二-懒加载和异步渲染"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二-懒加载和异步渲染"}},[t._v("#")]),t._v(" 二 懒加载和异步渲染")]),t._v(" "),a("h3",{attrs:{id:"异步渲染"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步渲染"}},[t._v("#")]),t._v(" 异步渲染")]),t._v(" "),a("p",[t._v("Suspense实现了异步请求结束后再进行组件的渲染，也就是所谓的异步渲染")]),t._v(" "),a("h4",{attrs:{id:"suspense用法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#suspense用法"}},[t._v("#")]),t._v(" Suspense用法")]),t._v(" "),a("p",[t._v("Suspense 是组件，有一个 fallback 属性，用来代替当 Suspense 处于 loading 状态下渲染的内容")]),t._v(" "),a("p",[t._v("Suspense 的 children 就是"),a("strong",[t._v("异步组件")]),t._v("。多个异步组件可以用 Suspense 嵌套使用")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Suspense fallback"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("loading div"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("UserInfo"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("Suspense"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),a("p",[t._v("当 UserInfo 处于数据加载状态下，展示 Suspense 中 fallback 的内容")]),t._v(" "),a("p",[t._v("传统模式：挂载组件-> 请求数据 -> 再渲染组件\n异步模式：请求数据-> 渲染组件")]),t._v(" "),a("p",[t._v("不需要在mount完成后再请求数据，也不会因为数据交互后改变state产生的二次更新作用")]),t._v(" "),a("h3",{attrs:{id:"动态加载-懒加载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#动态加载-懒加载"}},[t._v("#")]),t._v(" 动态加载（懒加载）")]),t._v(" "),a("p",[t._v("Suspense 配合 React.lazy 可以实现动态加载功能")]),t._v(" "),a("p",[a("strong",[t._v("React.lazy")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" LazyComponent  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" React"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("lazy")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'./text'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("default")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Index")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Suspence falback"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("div"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("LazyComponent"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("Suspencse"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("函数需要调用import，必须返回一个Promise，且resolve一个default export 的组件")]),t._v(" "),a("p",[a("strong",[t._v("利于代码分割，不会让初始化的时候加载大量的文件")])]),t._v(" "),a("h4",{attrs:{id:"react-lazy和suspense实现动态加载的原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-lazy和suspense实现动态加载的原理"}},[t._v("#")]),t._v(" React.lazy和Suspense实现动态加载的原理")]),t._v(" "),a("p",[t._v("render 过程是同步执行的")]),t._v(" "),a("p",[t._v("Suspense 下允许 "),a("strong",[t._v("render => 发现异步请求 => 悬停，等待异步请求完毕 => 再次渲染展示数据")])]),t._v(" "),a("h5",{attrs:{id:"suspense"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#suspense"}},[t._v("#")]),t._v(" Suspense")]),t._v(" "),a("p",[t._v("内部通过try catch捕捉异常，异常通常是一个promise，Suspense内部处理完promise之后会重新render，达到异步渲染效果")]),t._v(" "),a("h2",{attrs:{id:"三-渲染错误边界"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三-渲染错误边界"}},[t._v("#")]),t._v(" 三 渲染错误边界")]),t._v(" "),a("p",[t._v("如果越靠近 APP 应用的根组件，渲染过程中出现问题造成的影响就越大，有可能直接造成白屏的情况")]),t._v(" "),a("p",[t._v("为了防止渲染异常情况 React 增加了 "),a("code",[t._v("componentDidCatch")]),t._v(" 和 "),a("code",[t._v("static getDerivedStateFromError()")]),t._v(" 两个额外的生命周期，去挽救由于渲染阶段出现问题造成 UI 界面无法显示的情况")]),t._v(" "),a("h3",{attrs:{id:"componentdidcatch"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#componentdidcatch"}},[t._v("#")]),t._v(" componentDidCatch")]),t._v(" "),a("p",[t._v("componentDidCatch() 会在commit阶段被调用，因此允许执行副作用")]),t._v(" "),a("p",[t._v("componentDidCatch 作用：")]),t._v(" "),a("ul",[a("li",[t._v("可以调用 setState 促使组件渲染，并做一些错误拦截功能。")]),t._v(" "),a("li",[t._v("监控组件，发生错误，上报错误日志。")])]),t._v(" "),a("h3",{attrs:{id:"static-getderivedstatefromerror"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#static-getderivedstatefromerror"}},[t._v("#")]),t._v(" static getDerivedStateFromError")]),t._v(" "),a("p",[t._v("React更期望用 getDerivedStateFromError 代替 componentDidCatch 用于处理渲染异常")]),t._v(" "),a("h2",{attrs:{id:"四-从diff-children看key的合理使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四-从diff-children看key的合理使用"}},[t._v("#")]),t._v(" 四 从diff children看key的合理使用")]),t._v(" "),a("p",[t._v("React 在一次更新中当发现通过 render 得到的 children 如果是一个数组的话。就会调用 reconcileChildrenArray 来调和子代 fiber ，整个对比的流程就是在这个函数中进行的")]),t._v(" "),a("h3",{attrs:{id:"diff-children流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#diff-children流程"}},[t._v("#")]),t._v(" diff children流程")]),t._v(" "),a("p",[a("strong",[t._v("第一步：遍历新 children ，复用 oldFiber")])]),t._v(" "),a("blockquote",[a("p",[t._v("react-reconciler/src/ReactChildFiber.js")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("reconcileChildrenArray")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 第一步  */")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" oldFiber "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!==")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" newIdx "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" newChildren"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" newIdx"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("  \n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("oldFiber"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("index "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" newIdx"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            nextOldFiber "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" oldFiber"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            oldFiber "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            nextOldFiber "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" oldFiber"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("sibling"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" newFiber "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("updateSlot")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("returnFiber"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("oldFiber"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("newChildren"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("newIdx"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("expirationTime"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("newFiber "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("break")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ..一些其他逻辑")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("  \n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("shouldTrackSideEffects"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// shouldTrackSideEffects 为更新流程。")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("oldFiber "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" newFiber"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("alternate "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 找到了与新节点对应的fiber，但是不能复用，那么直接删除老节点 */")]),t._v("\n                "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("deleteChild")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("returnFiber"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" oldFiber"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[a("strong",[t._v("第二步：统一删除oldfiber")])]),t._v(" "),a("p",[a("strong",[t._v("第三步：统一创建newFiber")])]),t._v(" "),a("p",[a("strong",[t._v("第四步：针对发生移动和更复杂的情况")])]),t._v(" "),a("p",[a("strong",[t._v("第五步：删除剩余没有复用的oldFiber")])]),t._v(" "),a("h1",{attrs:{id:"处理海量数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#处理海量数据"}},[t._v("#")]),t._v(" 处理海量数据")]),t._v(" "),a("h2",{attrs:{id:"时间分片"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#时间分片"}},[t._v("#")]),t._v(" 时间分片")]),t._v(" "),a("p",[t._v("时间分片主要解决，初次加载，一次性渲染大量数据造成的卡顿现象")]),t._v(" "),a("p",[t._v("时间分片，并没有本质减少浏览器的工作量，而是把一次性任务分割开来，给用户一种流畅的体验效果")]),t._v(" "),a("h2",{attrs:{id:"虚拟列表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#虚拟列表"}},[t._v("#")]),t._v(" 虚拟列表")]),t._v(" "),a("h1",{attrs:{id:"细节处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#细节处理"}},[t._v("#")]),t._v(" 细节处理")]),t._v(" "),a("h3",{attrs:{id:"_1-react中防抖和节流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-react中防抖和节流"}},[t._v("#")]),t._v(" 1 React中防抖和节流")]),t._v(" "),a("h4",{attrs:{id:"防抖d"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#防抖d"}},[t._v("#")]),t._v(" 防抖d")]),t._v(" "),a("h4",{attrs:{id:"节流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#节流"}},[t._v("#")]),t._v(" 节流")]),t._v(" "),a("h3",{attrs:{id:"_2-按需引入"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-按需引入"}},[t._v("#")]),t._v(" 2 按需引入")]),t._v(" "),a("h3",{attrs:{id:"_3-react动画"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-react动画"}},[t._v("#")]),t._v(" 3 React动画")]),t._v(" "),a("h4",{attrs:{id:"_1-首选-动态添加类名"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-首选-动态添加类名"}},[t._v("#")]),t._v(" ① 首选：动态添加类名")]),t._v(" "),a("p",[t._v("通过 transition，animation 实现动画然后写在 class 类名里面，通过动态切换类名，达到动画的目的")]),t._v(" "),a("h4",{attrs:{id:"_2-其次-操纵原生-dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-其次-操纵原生-dom"}},[t._v("#")]),t._v(" ② 其次：操纵原生 DOM")]),t._v(" "),a("h4",{attrs:{id:"_3-再者-setstate-css3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-再者-setstate-css3"}},[t._v("#")]),t._v(" ③ 再者：setState + css3")]),t._v(" "),a("h3",{attrs:{id:"_4-及时清除定时器-延时器-监听器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-及时清除定时器-延时器-监听器"}},[t._v("#")]),t._v(" 4 及时清除定时器/延时器/监听器")]),t._v(" "),a("h3",{attrs:{id:"_5-合理使用state"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-合理使用state"}},[t._v("#")]),t._v(" 5 合理使用state")]),t._v(" "),a("h3",{attrs:{id:"_6-建议不要在-hooks-的参数中执行函数或者-new-实例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-建议不要在-hooks-的参数中执行函数或者-new-实例"}},[t._v("#")]),t._v(" 6 建议不要在 hooks 的参数中执行函数或者 new 实例")])])}),[],!1,null,null,null);s.default=n.exports}}]);