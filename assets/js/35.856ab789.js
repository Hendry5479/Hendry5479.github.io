(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{381:function(v,_,t){"use strict";t.r(_);var e=t(45),n=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("p",[v._v("DOM文档模型：")]),v._v(" "),t("ol",[t("li",[v._v("将文档建模映射到一个树形结构，就是DOM树。")]),v._v(" "),t("li",[v._v("提供一系列API给JS，带来高效的交互方式。")])]),v._v(" "),t("h3",{attrs:{id:"事件模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事件模型"}},[v._v("#")]),v._v(" 事件模型")]),v._v(" "),t("p",[v._v("**事件：**js和html交互的方式")]),v._v(" "),t("p",[t("strong",[v._v("标准事件模型的事件流三个阶段")])]),v._v(" "),t("ol",[t("li",[v._v("事件捕获：从不精准的document到精准的节点，遇到监听函数就执行")]),v._v(" "),t("li",[v._v("事件目标：执行处理函数")]),v._v(" "),t("li",[v._v("事件冒泡：从精准的节点到不精准的节点document，遇到监听函数就执行")])]),v._v(" "),t("p",[v._v("JS只能执行捕获或者冒泡的其中一个，大多数是冒泡")]),v._v(" "),t("p",[v._v("**事件对象：**事件相关数据的集合")]),v._v(" "),t("p",[v._v("常见属性：")]),v._v(" "),t("p",[v._v("target")]),v._v(" "),t("p",[v._v("preventDefault：阻止默认事件标准")]),v._v(" "),t("p",[v._v("stopPropogation：阻止冒泡")]),v._v(" "),t("p",[t("strong",[v._v("事件模型")])]),v._v(" "),t("p",[v._v("原始：DOM 0 级，例如onclick，只支持冒泡，只能绑定一个同类型事件")]),v._v(" "),t("p",[v._v("标准：DOM 2 级，例如addEventListener")]),v._v(" "),t("p",[v._v("IE不用")]),v._v(" "),t("p",[t("strong",[v._v("事件委托")])]),v._v(" "),t("p",[v._v("给父节点设置统一的监听器，利用冒泡原理，减少交互次数，提升性能")]),v._v(" "),t("p",[t("strong",[v._v("defer和async")]),v._v("的区别")]),v._v(" "),t("p",[v._v("普通script：立即解析执行")]),v._v(" "),t("p",[v._v("defer：延迟至HTML解析完成后，并且在DOMContentLoaded调用之前执行")]),v._v(" "),t("p",[v._v("async：加载完成后执行，依然会占用主线程")]),v._v(" "),t("p",[v._v("应用：defer的脚本会按照加载顺序去执行，适用于有依赖关系的脚本。而async的脚本执行紧挨着加载，适用于没有依赖关系的脚本")]),v._v(" "),t("p",[t("strong",[v._v("load和DOMContentLoaded的区别")]),v._v("：文档加载和解析完成后调用DOMContentLoaded，css图像等所有资源加载完成后调用load")])])}),[],!1,null,null,null);_.default=n.exports}}]);