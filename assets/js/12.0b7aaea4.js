(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{398:function(t,l,_){"use strict";_.r(l);var s=_(45),v=Object(s.a)({},(function(){var t=this,l=t.$createElement,_=t._self._c||l;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h3",{attrs:{id:"_1-对this对象的理解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-对this对象的理解"}},[t._v("#")]),t._v(" 1. 对this对象的理解")]),t._v(" "),_("p",[t._v("直接调用，指向全局对象")]),t._v(" "),_("p",[t._v("对象属性调用，指向对象")]),t._v(" "),_("p",[t._v("构造函数调用，执行前构造函数会new 一个对象，this指向新对象")]),t._v(" "),_("p",[t._v("apply等改变this指向")]),t._v(" "),_("p",[t._v("this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。")]),t._v(" "),_("p",[t._v("在实际开发中，this 的指向可以通过四种调用模式来判断。")]),t._v(" "),_("ul",[_("li",[t._v("1."),_("strong",[t._v("函数调用模式")]),t._v("，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。")]),t._v(" "),_("li",[t._v("2."),_("strong",[t._v("方法调用模式")]),t._v("，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。")]),t._v(" "),_("li",[t._v("3."),_("strong",[t._v("构造器调用模式")]),t._v("，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。")]),t._v(" "),_("li",[t._v("4."),_("strong",[t._v("apply 、 call 和 bind 调用模式")]),t._v("，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。")])]),t._v(" "),_("p",[t._v("这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。")]),t._v(" "),_("h3",{attrs:{id:"_2-call-和-apply-的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-call-和-apply-的区别"}},[t._v("#")]),t._v(" 2. call() 和 apply() 的区别？")]),t._v(" "),_("p",[t._v("它们的作用一模一样，区别仅在于传入参数的形式的不同。")]),t._v(" "),_("ul",[_("li",[t._v("apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。")]),t._v(" "),_("li",[t._v("call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。")])])])}),[],!1,null,null,null);l.default=v.exports}}]);