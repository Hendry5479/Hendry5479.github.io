(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{403:function(t,e,n){"use strict";n.r(e);var v=n(45),s=Object(v.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("ol",[n("li",[t._v("Fiber")])]),t._v(" "),n("p",[t._v("React 的核心流程分为reconciliation （render）调度和commit")]),t._v(" "),n("p",[t._v("reconciliation "),n("strong",[t._v("render")])]),t._v(" "),n("ul",[n("li",[t._v("更新 state 与 props")]),t._v(" "),n("li",[t._v("调用生命周期钩子")]),t._v(" "),n("li",[t._v("生成 Fiber Tree")]),t._v(" "),n("li",[t._v("diff 算法，获取 vdom change")]),t._v(" "),n("li",[t._v("确定是否需要重新渲染")])]),t._v(" "),n("p",[n("strong",[t._v("commit")])]),t._v(" "),n("ul",[n("li",[t._v("操作 dom 节点更新；")])]),t._v(" "),n("p",[n("strong",[t._v("对Fiber的认识：")])]),t._v(" "),n("p",[t._v("React16的Fiber之前，更新是无法中断的，所以大量的组件渲染时，主进程会长期占用同步阻塞，造成页面卡顿掉帧。")]),t._v(" "),n("p",[t._v("为了实现可中断更新，改变调度reconciler，从stack改成fiber，将一次同步更新任务分割成多个小任务，以fiber为更小的任务单位承载渲染，实现更新的可中断特性。")]),t._v(" "),n("p",[t._v("fiber如何实现更新可中断呢")]),t._v(" "),n("p",[n("strong",[t._v("核心")]),t._v(":")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("Fiber 具象为一个 "),n("strong",[t._v("数据结构")]),t._v("，有child、return、sibling指针，通过指针连接形成一个Fiber树")])]),t._v(" "),n("li",[n("p",[t._v("Fiber树的遍历算法，遍历过程对节点保存和映射实现随时的停止和回复，从而支持任务分割的特性。")])]),t._v(" "),n("li",[n("p",[n("strong",[t._v("链表树遍历算法")]),t._v(": 通过 "),n("strong",[t._v("节点保存与映射")]),t._v("，便能够随时地进行 停止和重启，这样便能达到实现任务分割的基本前提；")]),t._v(" "),n("ul",[n("li",[t._v("1、首先通过不断遍历子节点，到树末尾；")]),t._v(" "),n("li",[t._v("2、开始通过 sibling 遍历兄弟节点；")]),t._v(" "),n("li",[t._v("3、return 返回父节点，继续执行2；")]),t._v(" "),n("li",[t._v("4、直到 root 节点后，跳出遍历；")])])]),t._v(" "),n("li",[n("p",[n("strong",[t._v("任务分割")]),t._v("，React 中的渲染更新可以分成两个阶段:")]),t._v(" "),n("ul",[n("li",[n("strong",[t._v("reconciliation 阶段")]),t._v(": vdom 的数据对比，是个适合拆分的阶段，比如对比一部分树后，先暂停执行个动画调用，待完成后再回来继续比对。")]),t._v(" "),n("li",[n("strong",[t._v("Commit 阶段")]),t._v(": 将 change list 更新到 dom 上，并不适合拆分，才能保持数据与 UI 的同步。否则可能由于阻塞 UI 更新，而导致数据更新和 UI 不一致的情况。")])])]),t._v(" "),n("li",[n("p",[n("strong",[t._v("分散执行")]),t._v(": 任务分割后，就可以把小任务单元分散到浏览器的空闲期间去排队执行，而实现的关键是两个新API: "),n("code",[t._v("requestIdleCallback")]),t._v(" 与 "),n("code",[t._v("requestAnimationFrame")])]),t._v(" "),n("ul",[n("li",[t._v("低优先级的任务交给"),n("code",[t._v("requestIdleCallback")]),t._v("处理，这是个浏览器提供的事件循环空闲期的回调函数，需要 pollyfill，而且拥有 deadline 参数，限制执行事件，以继续切分任务；")]),t._v(" "),n("li",[t._v("高优先级的任务交给"),n("code",[t._v("requestAnimationFrame")]),t._v("处理；")])])])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// 类似于这样的方式\nrequestIdleCallback((deadline) => {\n    // 当有空闲时间时，我们执行一个组件渲染；\n    // 把任务塞到一个个碎片时间中去；\n    while ((deadline.timeRemaining() > 0 || deadline.didTimeout) && nextComponent) {\n        nextComponent = performWork(nextComponent);\n    }\n});\n复制代码\n")])])]),n("ul",[n("li",[n("strong",[t._v("优先级策略")]),t._v(": 文本框输入 > 本次调度结束需完成的任务 > 动画过渡 > 交互反馈 > 数据更新 > 不会显示但以防将来会显示的任务")])]),t._v(" "),n("h3",{attrs:{id:"_2-生命周期"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-生命周期"}},[t._v("#")]),t._v(" 2. 生命周期")]),t._v(" "),n("p",[t._v("因为fiber架构出现，生命周期的新"),n("strong",[t._v("变动")]),t._v(":")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("使用"),n("code",[t._v("getDerivedStateFromProps")]),t._v(" 替换 "),n("code",[t._v("componentWillMount")]),t._v(" 与 "),n("code",[t._v("componentWillReceiveProps")]),t._v("；")])]),t._v(" "),n("li",[n("p",[t._v("使用"),n("code",[t._v("getSnapshotBeforeUpdate")]),t._v("替换"),n("code",[t._v("componentWillUpdate")]),t._v("；")])]),t._v(" "),n("li",[n("p",[t._v("避免使用"),n("code",[t._v("componentWillReceiveProps")]),t._v("；")])]),t._v(" "),n("li",[n("p",[t._v("** reconciliation**:")]),t._v(" "),n("ul",[n("li",[n("code",[t._v("componentWillMount")])]),t._v(" "),n("li",[n("code",[t._v("componentWillReceiveProps")])]),t._v(" "),n("li",[n("code",[t._v("shouldComponentUpdate")])]),t._v(" "),n("li",[n("code",[t._v("componentWillUpdate")])])])]),t._v(" "),n("li",[n("p",[n("strong",[t._v("commit")]),t._v(":")]),t._v(" "),n("ul",[n("li",[n("code",[t._v("componentDidMount")])]),t._v(" "),n("li",[n("code",[t._v("componentDidUpdate")])]),t._v(" "),n("li",[n("code",[t._v("componentWillUnmount")])])])])]),t._v(" "),n("p",[t._v("在 Fiber 中，reconciliation 阶段进行了任务分割，涉及到 暂停 和 重启，因此可能会导致 reconciliation 中的生命周期函数在一次更新渲染循环中被 "),n("strong",[t._v("多次调用")]),t._v(" 的情况，产生一些意外错误。")]),t._v(" "),n("p",[t._v("新版的建议生命周期如下:")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class Component extends React.Component {\n  // 替换 `componentWillReceiveProps` ，\n  // 初始化和 update 时被调用\n  // 静态函数，无法使用 this\n  static getDerivedStateFromProps(nextProps, prevState) {}\n  \n  // 判断是否需要更新组件\n  // 可以用于组件性能优化\n  shouldComponentUpdate(nextProps, nextState) {}\n  \n  // 组件被挂载后触发\n  componentDidMount() {}\n  \n  // 替换 componentWillUpdate\n  // 可以在更新之前获取最新 dom 数据\n  getSnapshotBeforeUpdate() {}\n  \n  // 组件更新后调用\n  componentDidUpdate() {}\n  \n  // 组件即将销毁\n  componentWillUnmount() {}\n  \n  // 组件已销毁\n  componentDidUnmount() {}\n}\n复制代码\n")])])]),n("ul",[n("li",[n("p",[n("strong",[t._v("使用建议")]),t._v(":")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("在"),n("code",[t._v("constructor")]),t._v("初始化 state；")])]),t._v(" "),n("li",[n("p",[t._v("在"),n("code",[t._v("componentDidMount")]),t._v("中进行事件监听，并在"),n("code",[t._v("componentWillUnmount")]),t._v("中解绑事件；")])]),t._v(" "),n("li",[n("p",[t._v("在"),n("code",[t._v("componentDidMount")]),t._v("中进行数据的请求，而不是在"),n("code",[t._v("componentWillMount")]),t._v("；")])]),t._v(" "),n("li",[n("p",[t._v("需要根据 props 更新 state 时，使用")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("getDerivedStateFromProps(nextProps, prevState)\n")])])]),n("ul",[n("li",[t._v("旧 props 需要自己存储，以便比较；")])])])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("public static getDerivedStateFromProps(nextProps, prevState) {\n\t// 当新 props 中的 data 发生变化时，同步更新到 state 上\n\tif (nextProps.data !== prevState.data) {\n\t\treturn {\n\t\t\tdata: nextProps.data\n\t\t}\n\t} else {\n\t\treturn null1\n\t}\n}\n复制代码\n")])])]),n("ul",[n("li",[t._v("可以在"),n("code",[t._v("componentDidUpdate")]),t._v("监听 props 或者 state 的变化，例如:")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("componentDidUpdate(prevProps) {\n\t// 当 id 发生变化时，重新获取数据\n\tif (this.props.id !== prevProps.id) {\n\t\tthis.fetchData(this.props.id);\n\t}\n}\n复制代码\n")])])]),n("ul",[n("li",[t._v("在"),n("code",[t._v("componentDidUpdate")]),t._v("使用"),n("code",[t._v("setState")]),t._v("时，必须加条件，否则将进入死循环；")]),t._v(" "),n("li",[n("code",[t._v("getSnapshotBeforeUpdate(prevProps, prevState)")]),t._v("可以在更新之前获取最新的渲染数据，它的调用是在 render 之后， update 之前；")]),t._v(" "),n("li",[n("code",[t._v("shouldComponentUpdate")]),t._v(": 默认每次调用"),n("code",[t._v("setState")]),t._v("，一定会最终走到 diff 阶段，但可以通过"),n("code",[t._v("shouldComponentUpdate")]),t._v("的生命钩子返回"),n("code",[t._v("false")]),t._v("来直接阻止后面的逻辑执行，通常是用于做条件渲染，优化渲染的性能。")])])])]),t._v(" "),n("h3",{attrs:{id:"_3-setstate"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-setstate"}},[t._v("#")]),t._v(" 3. setState")]),t._v(" "),n("p",[t._v("在了解"),n("code",[t._v("setState")]),t._v("之前，我们先来简单了解下 React 一个包装结构: "),n("strong",[t._v("Transaction")]),t._v(":")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("事务")]),t._v(" "),n("p",[t._v("(Transaction):")]),t._v(" "),n("ul",[n("li",[t._v("是 React 中的一个调用结构，用于包装一个方法，结构为: "),n("strong",[t._v("initialize - perform(method) - close")]),t._v("。通过事务，可以统一管理一个方法的开始与结束；处于事务流中，表示进程正在执行一些操作；")])])])]),t._v(" "),n("p",[n("img",{attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/21/1699e0cb48cd4013~tplv-t2oaga2asx-watermark.awebp",alt:"img"}})]),t._v(" "),n("ul",[n("li",[n("p",[n("code",[t._v("setState")]),t._v(": React 中用于修改状态，更新视图。它具有以下特点:")])]),t._v(" "),n("li",[n("p",[n("strong",[t._v("异步与同步")]),t._v(": "),n("code",[t._v("setState")]),t._v("并不是单纯的异步或同步，这其实与调用时的环境相关:")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("在")]),t._v(" "),n("p",[t._v("合成事件")]),t._v(" "),n("p",[t._v("和")]),t._v(" "),n("p",[t._v("生命周期钩子(除 componentDidUpdate)")]),t._v(" "),n("p",[t._v("中，")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("setState\n")])])]),n("p",[t._v('是"异步"的；')]),t._v(" "),n("ul",[n("li",[n("p",[t._v("原因")]),t._v(" "),n("p",[t._v(": 因为在")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("setState\n")])])]),n("p",[t._v("的实现中，有一个判断: 当更新策略正在事务流的执行中时，该组件更新会被推入")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("dirtyComponents\n")])])]),n("p",[t._v("队列中等待执行；否则，开始执行")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("batchedUpdates\n")])])]),n("p",[t._v("队列更新；")]),t._v(" "),n("ul",[n("li",[t._v("在生命周期钩子调用中，更新策略都处于更新之前，组件仍处于事务流中，而"),n("code",[t._v("componentDidUpdate")]),t._v("是在更新之后，此时组件已经不在事务流中了，因此则会同步执行；")]),t._v(" "),n("li",[t._v("在合成事件中，React 是基于 "),n("strong",[t._v("事务流完成的事件委托机制")]),t._v(" 实现，也是处于事务流中；")])])]),t._v(" "),n("li",[n("p",[n("strong",[t._v("问题")]),t._v(": 无法在"),n("code",[t._v("setState")]),t._v("后马上从"),n("code",[t._v("this.state")]),t._v("上获取更新后的值。")])]),t._v(" "),n("li",[n("p",[n("strong",[t._v("解决")]),t._v(": 如果需要马上同步去获取新值，"),n("code",[t._v("setState")]),t._v("其实是可以传入第二个参数的。"),n("code",[t._v("setState(updater, callback)")]),t._v("，在回调中即可获取最新值；")])])])]),t._v(" "),n("li",[n("p",[t._v("在")]),t._v(" "),n("p",[t._v("原生事件")]),t._v(" "),n("p",[t._v("和")]),t._v(" "),n("p",[t._v("setTimeout")]),t._v(" "),n("p",[t._v("中，")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("setState\n")])])]),n("p",[t._v("是同步的，可以马上获取更新后的值；")]),t._v(" "),n("ul",[n("li",[t._v("原因: 原生事件是浏览器本身的实现，与事务流无关，自然是同步；而"),n("code",[t._v("setTimeout")]),t._v("是放置于定时器线程中延后执行，此时事务流已结束，因此也是同步；")])])])])]),t._v(" "),n("li",[n("p",[n("strong",[t._v("批量更新")]),t._v(": 在 "),n("strong",[t._v("合成事件")]),t._v(" 和 "),n("strong",[t._v("生命周期钩子")]),t._v(" 中，"),n("code",[t._v("setState")]),t._v("更新队列时，存储的是 "),n("strong",[t._v("合并状态")]),t._v("("),n("code",[t._v("Object.assign")]),t._v(")。因此前面设置的 key 值会被后面所覆盖，最终只会执行一次更新；")])]),t._v(" "),n("li",[n("p",[n("strong",[t._v("函数式")]),t._v(": 由于 Fiber 及 合并 的问题，官方推荐可以传入 "),n("strong",[t._v("函数")]),t._v(" 的形式。"),n("code",[t._v("setState(fn)")]),t._v("，在"),n("code",[t._v("fn")]),t._v("中返回新的"),n("code",[t._v("state")]),t._v("对象即可，例如"),n("code",[t._v("this.setState((state, props) => newState)；")])]),t._v(" "),n("ul",[n("li",[t._v("使用函数式，可以用于避免"),n("code",[t._v("setState")]),t._v("的批量更新的逻辑，传入的函数将会被 "),n("strong",[t._v("顺序调用")]),t._v("；")])])]),t._v(" "),n("li",[n("p",[n("strong",[t._v("注意事项")]),t._v(":")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("setState 合并，在 合成事件 和 生命周期钩子 中多次连续调用会被优化为一次；")])]),t._v(" "),n("li",[n("p",[t._v("当组件已被销毁，如果再次调用")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("setState\n")])])]),n("p",[t._v("，React 会报错警告，通常有两种解决办法:")]),t._v(" "),n("ul",[n("li",[t._v("将数据挂载到外部，通过 props 传入，如放到 Redux 或 父级中；")]),t._v(" "),n("li",[t._v("在组件内部维护一个状态量 (isUnmounted)，"),n("code",[t._v("componentWillUnmount")]),t._v("中标记为 true，在"),n("code",[t._v("setState")]),t._v("前进行判断；")])])])])])]),t._v(" "),n("h3",{attrs:{id:"_4-hoc-高阶组件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-hoc-高阶组件"}},[t._v("#")]),t._v(" 4. HOC(高阶组件)")]),t._v(" "),n("p",[t._v("HOC(Higher Order Componennt) 是在 React 机制下社区形成的一种组件模式，在很多第三方开源库中表现强大。")]),t._v(" "),n("ul",[n("li",[n("p",[n("strong",[t._v("简述")]),t._v(":")]),t._v(" "),n("ul",[n("li",[t._v("高阶组件不是组件，是 "),n("strong",[t._v("增强函数")]),t._v("，可以输入一个元组件，返回出一个新的增强组件；")]),t._v(" "),n("li",[t._v("高阶组件的主要作用是 "),n("strong",[t._v("代码复用")]),t._v("，"),n("strong",[t._v("操作")]),t._v(" 状态和参数；")])])]),t._v(" "),n("li",[n("p",[n("strong",[t._v("用法")]),t._v(":")]),t._v(" "),n("ul",[n("li",[n("p",[n("strong",[t._v("属性代理 (Props Proxy)")]),t._v(": 返回出一个组件，它基于被包裹组件进行 "),n("strong",[t._v("功能增强")]),t._v("；")]),t._v(" "),n("ul",[n("li",[n("strong",[t._v("默认参数")]),t._v(": 可以为组件包裹一层默认参数；")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function proxyHoc(Comp) {\n\treturn class extends React.Component {\n\t\trender() {\n\t\t\tconst newProps = {\n\t\t\t\tname: 'tayde',\n\t\t\t\tage: 1,\n\t\t\t}\n\t\t\treturn <Comp {...this.props} {...newProps} />\n\t\t}\n\t}\n}\n复制代码\n")])])]),n("ul",[n("li",[n("strong",[t._v("提取状态")]),t._v(": 可以通过 props 将被包裹组件中的 state 依赖外层，例如用于转换受控组件:")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function withOnChange(Comp) {\n\treturn class extends React.Component {\n\t\tconstructor(props) {\n\t\t\tsuper(props)\n\t\t\tthis.state = {\n\t\t\t\tname: '',\n\t\t\t}\n\t\t}\n\t\tonChangeName = () => {\n\t\t\tthis.setState({\n\t\t\t\tname: 'dongdong',\n\t\t\t})\n\t\t}\n\t\trender() {\n\t\t\tconst newProps = {\n\t\t\t\tvalue: this.state.name,\n\t\t\t\tonChange: this.onChangeName,\n\t\t\t}\n\t\t\treturn <Comp {...this.props} {...newProps} />\n\t\t}\n\t}\n}\n复制代码\n")])])]),n("p",[t._v("使用姿势如下，这样就能非常快速的将一个 "),n("code",[t._v("Input")]),t._v(" 组件转化成受控组件。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('const NameInput = props => (<input name="name" {...props} />)\nexport default withOnChange(NameInput)\n复制代码\n')])])]),n("ul",[n("li",[n("strong",[t._v("包裹组件")]),t._v(": 可以为被包裹元素进行一层包装，")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function withMask(Comp) {\n  return class extends React.Component {\n      render() {\n\t\t  return (\n\t\t      <div>\n\t\t\t\t  <Comp {...this.props} />\n\t\t\t\t\t<div style={{\n\t\t\t\t\t  width: '100%',\n\t\t\t\t\t  height: '100%',\n\t\t\t\t\t  backgroundColor: 'rgba(0, 0, 0, .6)',\n\t\t\t\t  }} \n\t\t\t  </div>\n\t\t  )\n\t  }\n  }\n}\n复制代码\n")])])])]),t._v(" "),n("li",[n("p",[n("strong",[t._v("反向继承")]),t._v(" (Inheritance Inversion): 返回出一个组件，"),n("strong",[t._v("继承于被包裹组件")]),t._v("，常用于以下操作:")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function IIHoc(Comp) {\n    return class extends Comp {\n        render() {\n            return super.render();\n        }\n    };\n}\n复制代码\n")])])]),n("ul",[n("li",[n("p",[n("strong",[t._v("渲染劫持")]),t._v(" (Render Highjacking)")]),t._v(" "),n("ul",[n("li",[n("strong",[t._v("条件渲染")]),t._v(": 根据条件，渲染不同的组件")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function withLoading(Comp) {\n    return class extends Comp {\n        render() {\n            if(this.props.isLoading) {\n                return <Loading />\n            } else {\n                return super.render()\n            }\n        }\n    };\n}\n复制代码\n")])])]),n("ul",[n("li",[t._v("可以直接修改被包裹组件渲染出的 React 元素树")])])]),t._v(" "),n("li",[n("p",[n("strong",[t._v("操作状态")]),t._v(" (Operate State): 可以直接通过 "),n("code",[t._v("this.state")]),t._v(" 获取到被包裹组件的状态，并进行操作。但这样的操作容易使 state 变得难以追踪，不易维护，谨慎使用。")])])])])])]),t._v(" "),n("li",[n("p",[n("strong",[t._v("应用场景")]),t._v(":")]),t._v(" "),n("ul",[n("li",[n("strong",[t._v("权限控制")]),t._v("，通过抽象逻辑，统一对页面进行权限判断，按不同的条件进行页面渲染:")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function withAdminAuth(WrappedComponent) {\n    return class extends React.Component {\n\t\tconstructor(props){\n\t\t\tsuper(props)\n\t\t\tthis.state = {\n\t\t    \tisAdmin: false,\n\t\t\t}\n\t\t} \n\t\tasync componentWillMount() {\n\t\t    const currentRole = await getCurrentUserRole();\n\t\t    this.setState({\n\t\t        isAdmin: currentRole === 'Admin',\n\t\t    });\n\t\t}\n\t\trender() {\n\t\t    if (this.state.isAdmin) {\n\t\t        return <Comp {...this.props} />;\n\t\t    } else {\n\t\t        return (<div>您没有权限查看该页面，请联系管理员！</div>);\n\t\t    }\n\t\t}\n    };\n}\n复制代码\n")])])]),n("ul",[n("li",[n("strong",[t._v("性能监控")]),t._v("，包裹组件的生命周期，进行统一埋点:")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function withTiming(Comp) {\n    return class extends Comp {\n        constructor(props) {\n            super(props);\n            this.start = Date.now();\n            this.end = 0;\n        }\n        componentDidMount() {\n            super.componentDidMount && super.componentDidMount();\n            this.end = Date.now();\n            console.log(`${WrappedComponent.name} 组件渲染时间为 ${this.end - this.start} ms`);\n        }\n        render() {\n            return super.render();\n        }\n    };\n}\n复制代码\n")])])]),n("ul",[n("li",[n("strong",[t._v("代码复用")]),t._v("，可以将重复的逻辑进行抽象。")])])]),t._v(" "),n("li",[n("p",[t._v("使用注意:")]),t._v(" "),n("ul",[n("li",[n("ol",[n("li",[n("strong",[t._v("纯函数")]),t._v(": 增强函数应为纯函数，避免侵入修改元组件；")])])]),t._v(" "),n("li",[n("ol",[n("li",[n("strong",[t._v("避免用法污染")]),t._v(": 理想状态下，应透传元组件的无关参数与事件，尽量保证用法不变；")])])]),t._v(" "),n("li",[n("ol",[n("li",[n("strong",[t._v("命名空间")]),t._v(": 为 HOC 增加特异性的组件名称，这样能便于开发调试和查找问题；")])])]),t._v(" "),n("li",[n("ol",[n("li",[n("strong",[t._v("引用传递")]),t._v(": 如果需要传递元组件的 refs 引用，可以使用"),n("code",[t._v("React.forwardRef")]),t._v("；")])])]),t._v(" "),n("li",[n("ol",[n("li",[n("strong",[t._v("静态方法")]),t._v(": 元组件上的静态方法并无法被自动传出，会导致业务层无法调用；解决:")])]),t._v(" "),n("ul",[n("li",[t._v("函数导出")]),t._v(" "),n("li",[t._v("静态方法赋值")])])]),t._v(" "),n("li",[n("ol",[n("li",[n("strong",[t._v("重新渲染")]),t._v(": 由于增强函数每次调用是返回一个新组件，因此如果在 Render 中使用增强函数，就会导致每次都重新渲染整个HOC，而且之前的状态会丢失；")])])])])])]),t._v(" "),n("h3",{attrs:{id:"_5-redux"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-redux"}},[t._v("#")]),t._v(" 5. Redux")]),t._v(" "),n("p",[t._v("Redux 是一个 "),n("strong",[t._v("数据管理中心")]),t._v("，可以把它理解为一个全局的 data store 实例。它通过一定的使用规则和限制，保证着数据的健壮性、可追溯和可预测性。它与 React 无关，可以独立运行于任何 JavaScript 环境中，从而也为同构应用提供了更好的数据同步通道。")]),t._v(" "),n("ul",[n("li",[n("p",[n("strong",[t._v("核心理念")]),t._v(":")]),t._v(" "),n("ul",[n("li",[n("p",[n("strong",[t._v("单一数据源")]),t._v(": 整个应用只有唯一的状态树，也就是所有 state 最终维护在一个根级 Store 中；")])]),t._v(" "),n("li",[n("p",[t._v("状态只读")]),t._v(" "),n("p",[t._v(": 为了保证状态的可控性，最好的方式就是监控状态的变化。那这里就两个必要条件：")]),t._v(" "),n("ul",[n("li",[t._v("Redux Store 中的数据无法被直接修改；")]),t._v(" "),n("li",[t._v("严格控制修改的执行；")])])]),t._v(" "),n("li",[n("p",[n("strong",[t._v("纯函数")]),t._v(": 规定只能通过一个纯函数 (Reducer) 来描述修改；")])])])]),t._v(" "),n("li",[n("p",[t._v("大致的数据结构如下所示:")])])]),t._v(" "),n("p",[n("img",{attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/21/1699e0d09c40cec7~tplv-t2oaga2asx-watermark.awebp",alt:"img"}})]),t._v(" "),n("ul",[n("li",[n("p",[n("strong",[t._v("理念实现")]),t._v(":")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("Store")]),t._v(" "),n("p",[t._v(": 全局 Store 单例， 每个 Redux 应用下只有一个 store， 它具有以下方法供使用:")]),t._v(" "),n("ul",[n("li",[n("code",[t._v("getState")]),t._v(": 获取 state；")]),t._v(" "),n("li",[n("code",[t._v("dispatch")]),t._v(": 触发 action, 更新 state；")]),t._v(" "),n("li",[n("code",[t._v("subscribe")]),t._v(": 订阅数据变更，注册监听器；")])])])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// 创建\nconst store = createStore(Reducer, initStore)\n复制代码\n")])])]),n("ul",[n("li",[n("strong",[t._v("Action")]),t._v(": 它作为一个行为载体，用于映射相应的 Reducer，并且它可以成为数据的载体，将数据从应用传递至 store 中，是 store "),n("strong",[t._v("唯一的数据源")]),t._v("；")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// 一个普通的 Action\nconst action = {\n\ttype: 'ADD_LIST',\n\titem: 'list-item-1',\n}\n\n// 使用：\nstore.dispatch(action)\n\n// 通常为了便于调用，会有一个 Action 创建函数 (action creater)\nfuntion addList(item) {\n\treturn const action = {\n\t\ttype: 'ADD_LIST',\n\t\titem,\n\t}\n}\n\n// 调用就会变成:\ndispatch(addList('list-item-1'))\n复制代码\n")])])]),n("ul",[n("li",[n("strong",[t._v("Reducer")]),t._v(": 用于描述如何修改数据的纯函数，Action 属于行为名称，而 Reducer 便是修改行为的实质；")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// 一个常规的 Reducer\n// @param {state}: 旧数据\n// @param {action}: Action 对象\n// @returns {any}: 新数据\nconst initList = []\nfunction ListReducer(state = initList, action) {\n\tswitch (action.type) {\n\t\tcase 'ADD_LIST':\n\t\t\treturn state.concat([action.item])\n\t\t\tbreak\n\t\tdefalut:\n\t\t\treturn state\n\t}\n}\n复制代码\n")])])]),n("blockquote",[n("p",[n("strong",[t._v("注意")]),t._v(":")]),t._v(" "),n("ol",[n("li",[t._v("遵守数据不可变，不要去直接修改 state，而是返回出一个 "),n("strong",[t._v("新对象")]),t._v("，可以使用 "),n("code",[t._v("assign / copy / extend / 解构")]),t._v(" 等方式创建新对象；")]),t._v(" "),n("li",[t._v("默认情况下需要 "),n("strong",[t._v("返回原数据")]),t._v("，避免数据被清空；")]),t._v(" "),n("li",[t._v("最好设置 "),n("strong",[t._v("初始值")]),t._v("，便于应用的初始化及数据稳定；")])])])]),t._v(" "),n("li",[n("p",[n("strong",[t._v("进阶")]),t._v(":")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("React-Redux")]),t._v(" "),n("p",[t._v(": 结合 React 使用；")]),t._v(" "),n("ul",[n("li",[n("p",[n("code",[t._v("<Provider>")]),t._v(": 将 store 通过 context 传入组件中；")])]),t._v(" "),n("li",[n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("connect\n")])])]),n("p",[t._v(": 一个高阶组件，可以方便在 React 组件中使用 Redux；")]),t._v(" "),n("ul",[n("li",[n("ol",[n("li",[t._v("将"),n("code",[t._v("store")]),t._v("通过"),n("code",[t._v("mapStateToProps")]),t._v("进行筛选后使用"),n("code",[t._v("props")]),t._v("注入组件")])])]),t._v(" "),n("li",[n("ol",[n("li",[t._v("根据"),n("code",[t._v("mapDispatchToProps")]),t._v("创建方法，当组件调用时使用"),n("code",[t._v("dispatch")]),t._v("触发对应的"),n("code",[t._v("action")])])])])])])])]),t._v(" "),n("li",[n("p",[t._v("Reducer 的拆分与重构")]),t._v(" "),n("p",[t._v(":")]),t._v(" "),n("ul",[n("li",[t._v("随着项目越大，如果将所有状态的 reducer 全部写在一个函数中，将会 "),n("strong",[t._v("难以维护")]),t._v("；")]),t._v(" "),n("li",[t._v("可以将 reducer 进行拆分，也就是 "),n("strong",[t._v("函数分解")]),t._v("，最终再使用"),n("code",[t._v("combineReducers()")]),t._v("进行重构合并；")])])]),t._v(" "),n("li",[n("p",[t._v("异步 Action")]),t._v(" "),n("p",[t._v(": 由于 Reducer 是一个严格的纯函数，因此无法在 Reducer 中进行数据的请求，需要先获取数据，再")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("dispatch(Action)\n")])])]),n("p",[t._v("即可，下面是三种不同的异步实现:")]),t._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Freduxjs%2Fredux-thunk",target:"_blank",rel:"noopener noreferrer"}},[t._v("redex-thunk"),n("OutboundLink")],1)]),t._v(" "),n("li",[n("a",{attrs:{href:"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fredux-saga%2Fredux-saga",target:"_blank",rel:"noopener noreferrer"}},[t._v("redux-saga"),n("OutboundLink")],1)]),t._v(" "),n("li",[n("a",{attrs:{href:"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fredux-observable%2Fredux-observable",target:"_blank",rel:"noopener noreferrer"}},[t._v("redux-observable"),n("OutboundLink")],1)])])])])])]),t._v(" "),n("h3",{attrs:{id:"_6-react-hooks"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-react-hooks"}},[t._v("#")]),t._v(" 6. React Hooks")]),t._v(" "),n("p",[t._v("React 中通常使用 "),n("strong",[t._v("类定义")]),t._v(" 或者 "),n("strong",[t._v("函数定义")]),t._v(" 创建组件:")]),t._v(" "),n("p",[t._v("在类定义中，我们可以使用到许多 React 特性，例如 state、 各种组件生命周期钩子等，但是在函数定义中，我们却无能为力，因此 React 16.8 版本推出了一个新功能 (React Hooks)，通过它，可以更好的在函数定义组件中使用 React 特性。")]),t._v(" "),n("ul",[n("li",[n("p",[n("strong",[t._v("好处")]),t._v(":")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("1、"),n("strong",[t._v("跨组件复用")]),t._v(": 其实 render props / HOC 也是为了复用，相比于它们，Hooks 作为官方的底层 API，最为轻量，而且改造成本小，不会影响原来的组件层次结构和传说中的嵌套地狱；")])]),t._v(" "),n("li",[n("p",[t._v("2、")]),t._v(" "),n("p",[t._v("类定义更为复杂")]),t._v(" "),n("p",[t._v(":")]),t._v(" "),n("ul",[n("li",[t._v("不同的生命周期会使逻辑变得分散且混乱，不易维护和管理；")]),t._v(" "),n("li",[t._v("时刻需要关注"),n("code",[t._v("this")]),t._v("的指向问题；")]),t._v(" "),n("li",[t._v("代码复用代价高，高阶组件的使用经常会使整个组件树变得臃肿；")])])]),t._v(" "),n("li",[n("p",[t._v("3、"),n("strong",[t._v("状态与UI隔离")]),t._v(": 正是由于 Hooks 的特性，状态逻辑会变成更小的粒度，并且极容易被抽象成一个自定义 Hooks，组件中的状态和 UI 变得更为清晰和隔离。")])])])]),t._v(" "),n("li",[n("p",[n("strong",[t._v("注意")]),t._v(":")]),t._v(" "),n("ul",[n("li",[t._v("避免在 循环/条件判断/嵌套函数 中调用 hooks，保证调用顺序的稳定；")]),t._v(" "),n("li",[t._v("只有 函数定义组件 和 hooks 可以调用 hooks，避免在 类组件 或者 普通函数 中调用；")]),t._v(" "),n("li",[t._v("不能在"),n("code",[t._v("useEffect")]),t._v("中使用"),n("code",[t._v("useState")]),t._v("，React 会报错提示；")]),t._v(" "),n("li",[t._v("类组件不会被替换或废弃，不需要强制改造类组件，两种方式能并存；")])])]),t._v(" "),n("li",[n("p",[n("strong",[t._v("重要钩子")]),t._v("*:")]),t._v(" "),n("ul",[n("li",[n("strong",[t._v("状态钩子")]),t._v(" ("),n("code",[t._v("useState")]),t._v("): 用于定义组件的 State，其到类定义中"),n("code",[t._v("this.state")]),t._v("的功能；")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// useState 只接受一个参数: 初始状态\n// 返回的是组件名和更改该组件对应的函数\nconst [flag, setFlag] = useState(true);\n// 修改状态\nsetFlag(false)\n\t\n// 上面的代码映射到类定义中:\nthis.state = {\n\tflag: true\t\n}\nconst flag = this.state.flag\nconst setFlag = (bool) => {\n    this.setState({\n        flag: bool,\n    })\n}\n复制代码\n")])])]),n("ul",[n("li",[n("strong",[t._v("生命周期钩子")]),t._v(" ("),n("code",[t._v("useEffect")]),t._v("):")])]),t._v(" "),n("p",[t._v("类定义中有许多生命周期函数，而在 React Hooks 中也提供了一个相应的函数 ("),n("code",[t._v("useEffect")]),t._v(")，这里可以看做"),n("code",[t._v("componentDidMount")]),t._v("、"),n("code",[t._v("componentDidUpdate")]),t._v("和"),n("code",[t._v("componentWillUnmount")]),t._v("的结合。")]),t._v(" "),n("ul",[n("li",[n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("useEffect(callback, [source])\n")])])]),n("p",[t._v("接受两个参数")]),t._v(" "),n("ul",[n("li",[n("code",[t._v("callback")]),t._v(": 钩子回调函数；")]),t._v(" "),n("li",[n("code",[t._v("source")]),t._v(": 设置触发条件，仅当 source 发生改变时才会触发；")]),t._v(" "),n("li",[n("code",[t._v("useEffect")]),t._v("钩子在没有传入"),n("code",[t._v("[source]")]),t._v("参数时，默认在每次 render 时都会优先调用上次保存的回调中返回的函数，后再重新调用回调；")])])])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("useEffect(() => {\n\t// 组件挂载后执行事件绑定\n\tconsole.log('on')\n\taddEventListener()\n\t\n\t// 组件 update 时会执行事件解绑\n\treturn () => {\n\t\tconsole.log('off')\n\t\tremoveEventListener()\n\t}\n}, [source]);\n\n\n// 每次 source 发生改变时，执行结果(以类定义的生命周期，便于大家理解):\n// --- DidMount ---\n// 'on'\n// --- DidUpdate ---\n// 'off'\n// 'on'\n// --- DidUpdate ---\n// 'off'\n// 'on'\n// --- WillUnmount --- \n// 'off'\n复制代码\n")])])]),n("ul",[n("li",[n("p",[t._v("通过第二个参数，我们便可模拟出几个常用的生命周期:")]),t._v(" "),n("ul",[n("li",[n("code",[t._v("componentDidMount")]),t._v(": 传入"),n("code",[t._v("[]")]),t._v("时，就只会在初始化时调用一次；")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const useMount = (fn) => useEffect(fn, [])\n复制代码\n")])])]),n("ul",[n("li",[n("code",[t._v("componentWillUnmount")]),t._v(": 传入"),n("code",[t._v("[]")]),t._v("，回调中的返回的函数也只会被最终执行一次；")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const useUnmount = (fn) => useEffect(() => fn, [])\n复制代码\n")])])]),n("ul",[n("li",[n("code",[t._v("mounted")]),t._v(": 可以使用 useState 封装成一个高度可复用的 mounted 状态；")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const useMounted = () => {\n    const [mounted, setMounted] = useState(false);\n    useEffect(() => {\n        !mounted && setMounted(true);\n        return () => setMounted(false);\n    }, []);\n    return mounted;\n}\n复制代码\n")])])]),n("ul",[n("li",[n("code",[t._v("componentDidUpdate")]),t._v(": "),n("code",[t._v("useEffect")]),t._v("每次均会执行，其实就是排除了 DidMount 后即可；")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const mounted = useMounted() \nuseEffect(() => {\n    mounted && fn()\n})\n复制代码\n")])])])])])]),t._v(" "),n("li",[n("p",[n("strong",[t._v("其它内置钩子")]),t._v(":")]),t._v(" "),n("ul",[n("li",[n("code",[t._v("useContext")]),t._v(": 获取 context 对象")]),t._v(" "),n("li",[n("code",[t._v("useReducer")]),t._v(": 类似于 Redux 思想的实现，但其并不足以替代 Redux，可以理解成一个组件内部的 redux:\n"),n("ul",[n("li",[t._v("并不是持久化存储，会随着组件被销毁而销毁；")]),t._v(" "),n("li",[t._v("属于组件内部，各个组件是相互隔离的，单纯用它并无法共享数据；")]),t._v(" "),n("li",[t._v("配合"),n("code",[t._v("useContext")]),t._v("的全局性，可以完成一个轻量级的 Redux；("),n("a",{attrs:{href:"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fctrlplusb%2Feasy-peasy",target:"_blank",rel:"noopener noreferrer"}},[t._v("easy-peasy"),n("OutboundLink")],1),t._v(")")])])]),t._v(" "),n("li",[n("code",[t._v("useCallback")]),t._v(": 缓存回调函数，避免传入的回调每次都是新的函数实例而导致依赖组件重新渲染，具有性能优化的效果；")]),t._v(" "),n("li",[n("code",[t._v("useMemo")]),t._v(": 用于缓存传入的 props，避免依赖的组件每次都重新渲染；")]),t._v(" "),n("li",[n("code",[t._v("useRef")]),t._v(": 获取组件的真实节点；")]),t._v(" "),n("li",[n("code",[t._v("useLayoutEffect")]),t._v(":\n"),n("ul",[n("li",[t._v("DOM更新同步钩子。用法与"),n("code",[t._v("useEffect")]),t._v("类似，只是区别于执行时间点的不同。")]),t._v(" "),n("li",[n("code",[t._v("useEffect")]),t._v("属于异步执行，并不会等待 DOM 真正渲染后执行，而"),n("code",[t._v("useLayoutEffect")]),t._v("则会真正渲染后才触发；")]),t._v(" "),n("li",[t._v("可以获取更新后的 state；")])])])])]),t._v(" "),n("li",[n("p",[n("strong",[t._v("自定义钩子")]),t._v("("),n("code",[t._v("useXxxxx")]),t._v("): 基于 Hooks 可以引用其它 Hooks 这个特性，我们可以编写自定义钩子，如上面的"),n("code",[t._v("useMounted")]),t._v("。又例如，我们需要每个页面自定义标题:")])])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function useTitle(title) {\n  useEffect(\n    () => {\n      document.title = title;\n    });\n}\n\n// 使用:\nfunction Home() {\n\tconst title = '我是首页'\n\tuseTitle(title)\n\t\n\treturn (\n\t\t<div>{title}</div>\n\t)\n}\n复制代码\n")])])]),n("h3",{attrs:{id:"_7-ssr"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_7-ssr"}},[t._v("#")]),t._v(" 7. SSR")]),t._v(" "),n("p",[t._v("SSR，俗称 "),n("strong",[t._v("服务端渲染")]),t._v(" (Server Side Render)，讲人话就是: 直接在服务端层获取数据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。")]),t._v(" "),n("ul",[n("li",[n("strong",[t._v("前后端分离")]),t._v(": 前端与服务端隔离，前端动态获取数据，渲染页面。")]),t._v(" "),n("li",[n("strong",[t._v("痛点")]),t._v(":\n"),n("ul",[n("li",[n("strong",[t._v("首屏渲染性能瓶颈")]),t._v(":\n"),n("ul",[n("li",[t._v("空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时间。在这段时间内，页面处于空白的状态。")])])]),t._v(" "),n("li",[n("strong",[t._v("SEO 问题")]),t._v(": 由于页面初始状态为空，因此爬虫无法获取页面中任何有效数据，因此对搜索引擎不友好。\n"),n("ul",[n("li",[t._v("虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜索引擎仍然是没有实现。")])])])])])]),t._v(" "),n("p",[t._v("最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独立的开发模式，又要由服务端渲染，因此我们使用 React SSR。")]),t._v(" "),n("ul",[n("li",[n("strong",[t._v("原理")]),t._v(":\n"),n("ul",[n("li",[t._v("Node 服务: 让前后端运行同一套代码成为可能。")]),t._v(" "),n("li",[t._v("Virtual Dom: 让前端代码脱离浏览器运行。")])])]),t._v(" "),n("li",[n("strong",[t._v("条件")]),t._v(": Node 中间层、 React / Vue 等框架。 结构大概如下:")])]),t._v(" "),n("p",[n("img",{attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/21/1699e0d41797a4d1~tplv-t2oaga2asx-watermark.awebp",alt:"img"}})]),t._v(" "),n("ul",[n("li",[n("p",[n("strong",[t._v("开发流程")]),t._v(": (此处以 React + Router + Redux + Koa 为例)")]),t._v(" "),n("ul",[n("li",[t._v("1、在同个项目中，"),n("strong",[t._v("搭建")]),t._v(" 前后端部分，常规结构:\n"),n("ul",[n("li",[t._v("build")]),t._v(" "),n("li",[t._v("public")]),t._v(" "),n("li",[t._v("src\n"),n("ul",[n("li",[t._v("client")]),t._v(" "),n("li",[t._v("server")])])])])]),t._v(" "),n("li",[t._v("2、server 中使用 Koa "),n("strong",[t._v("路由监听")]),t._v(" 页面访问:")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("import * as Router from 'koa-router'\n\nconst router = new Router()\n// 如果中间也提供 Api 层\nrouter.use('/api/home', async () => {\n\t// 返回数据\n})\n\nrouter.get('*', async (ctx) => {\n\t// 返回 HTML\n})\n复制代码\n")])])]),n("ul",[n("li",[t._v("3、通过访问 url "),n("strong",[t._v("匹配")]),t._v(" 前端页面路由:")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// 前端页面路由\nimport { pages } from '../../client/app'\nimport { matchPath } from 'react-router-dom'\n\n// 使用 react-router 库提供的一个匹配方法\nconst matchPage = matchPath(ctx.req.url, page)\n复制代码\n")])])]),n("ul",[n("li",[n("p",[t._v("4、通过页面路由的配置进行 "),n("strong",[t._v("数据获取")]),t._v("。通常可以在页面路由中增加 SSR 相关的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class HomePage extends React.Component{\n\tpublic static ssrConfig = {\n\t\t  cache: true,\n         fetch() {\n        \t  // 请求获取数据\n         }\n    }\n}\n复制代码\n")])])]),n("p",[t._v("获取数据通常有两种情况:")]),t._v(" "),n("ul",[n("li",[t._v("中间层也使用 "),n("strong",[t._v("http")]),t._v(" 获取数据，则此时 fetch 方法可前后端共享；")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const data = await matchPage.ssrConfig.fetch()\n复制代码\n")])])]),n("ul",[n("li",[t._v("中间层并不使用 http，是通过一些 "),n("strong",[t._v("内部调用")]),t._v("，例如 Rpc 或 直接读数据库 等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// 页面路由\nclass HomePage extends React.Component{\n\tpublic static ssrConfig = {\n        fetch: {\n        \t url: '/api/home',\n        }\n    }\n}\n\n// 根据规则匹配出对应的数据获取方法\n// 这里的规则可以自由，只要能匹配出正确的方法即可\nconst controller = matchController(ssrConfig.fetch.url)\n\n// 获取数据\nconst data = await controller(ctx)\n复制代码\n")])])])]),t._v(" "),n("li",[n("p",[t._v("5、创建 Redux store，并将数据"),n("code",[t._v("dispatch")]),t._v("到里面:")])])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("import { createStore } from 'redux'\n// 获取 Clinet层 reducer\n// 必须复用前端层的逻辑，才能保证一致性；\nimport { reducers } from '../../client/store'\n\n// 创建 store\nconst store = createStore(reducers)\n \n// 获取配置好的 Action\nconst action = ssrConfig.action\n\n// 存储数据\t\nstore.dispatch(createAction(action)(data))\n复制代码\n")])])]),n("ul",[n("li",[t._v("6、注入 Store， 调用"),n("code",[t._v("renderToString")]),t._v("将 React Virtual Dom 渲染成 "),n("strong",[t._v("字符串")]),t._v(":")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("import * as ReactDOMServer from 'react-dom/server'\nimport { Provider } from 'react-redux'\n\n// 获取 Clinet 层根组件\nimport { App } from '../../client/app'\n\nconst AppString = ReactDOMServer.renderToString(\n\t<Provider store={store}>\n\t\t<StaticRouter\n\t\t\tlocation={ctx.req.url}\n\t\t\tcontext={{}}>\n\t\t\t<App />\n\t\t</StaticRouter>\n\t</Provider>\n)\n复制代码\n")])])]),n("ul",[n("li",[t._v("7、将 AppString 包装成完整的 html 文件格式；")]),t._v(" "),n("li",[t._v("8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的页面，没有样式没有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成的"),n("code",[t._v("asset-manifest.json")]),t._v("文件来获取相应的文件路径，并同样注入到 Html 中引用。")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('const html = `\n\t<!DOCTYPE html>\n\t<html lang="zh">\n\t\t<head></head>\n\t\t<link href="${cssPath}" rel="stylesheet" />\n\t\t<body>\n\t\t\t<div id="App">${AppString}</div>\n\t\t\t<script src="${scriptPath}"><\/script>\n\t\t</body>\n\t</html>\n`\n复制代码\n')])])]),n("ul",[n("li",[t._v("9、进行 "),n("strong",[t._v("数据脱水")]),t._v(": 为了把服务端获取的数据同步到前端。主要是将数据序列化后，插入到 html 中，返回给前端。")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('import serialize from \'serialize-javascript\'\n// 获取数据\nconst initState = store.getState()\nconst html = `\n\t<!DOCTYPE html>\n\t<html lang="zh">\n\t\t<head></head>\n\t\t<body>\n\t\t\t<div id="App"></div>\n\t\t\t<script type="application/json" id="SSR_HYDRATED_DATA">${serialize(initState)}<\/script>\n\t\t</body>\n\t</html>\n`\n\nctx.status = 200\nctx.body = html\n复制代码\n')])])]),n("blockquote",[n("p",[n("strong",[t._v("Tips")]),t._v(":")]),t._v(" "),n("p",[t._v("这里比较特别的有两点:")]),t._v(" "),n("ol",[n("li",[t._v("使用了"),n("code",[t._v("serialize-javascript")]),t._v("序列化 store， 替代了"),n("code",[t._v("JSON.stringify")]),t._v("，保证数据的安全性，避免代码注入和 XSS 攻击；")]),t._v(" "),n("li",[t._v("使用 json 进行传输，可以获得更快的加载速度；")])])]),t._v(" "),n("ul",[n("li",[t._v("10、Client 层 "),n("strong",[t._v("数据吸水")]),t._v(": 初始化 store 时，以脱水后的数据为初始化数据，同步创建 store。")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')\nconst hydrateData = JSON.parse(hydratedEl.textContent)\n\n// 使用初始 state 创建 Redux store\nconst store = createStore(reducer, hydrateData)\n复制代码\n")])])])])]),t._v(" "),n("h3",{attrs:{id:"_8-函数式编程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_8-函数式编程"}},[t._v("#")]),t._v(" 8. 函数式编程")]),t._v(" "),n("p",[t._v("函数式编程是一种 "),n("strong",[t._v("编程范式")]),t._v("，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础与边界法则，追求的是 "),n("strong",[t._v("更简洁、可预测、高复用、易测试")]),t._v("。其实在现有的众多知名库中，都蕴含着丰富的函数式编程思想，如 React / Redux 等。")]),t._v(" "),n("ul",[n("li",[n("p",[n("strong",[t._v("常见的编程范式")]),t._v(":")]),t._v(" "),n("ul",[n("li",[t._v("命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做什么；")]),t._v(" "),n("li",[t._v("事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；")]),t._v(" "),n("li",[t._v("面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承性、多态性；")]),t._v(" "),n("li",[t._v("函数式编程\n"),n("ul",[n("li",[t._v("换成一种更高端的说法，面向数学编程。怕不怕~🥴")])])])])]),t._v(" "),n("li",[n("p",[n("strong",[t._v("函数式编程的理念")]),t._v(":")]),t._v(" "),n("ul",[n("li",[n("p",[n("strong",[t._v("纯函数")]),t._v("(确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维护；")]),t._v(" "),n("ul",[n("li",[n("strong",[t._v("优势")]),t._v(":\n"),n("ul",[n("li",[t._v("完全独立，与外部解耦；")]),t._v(" "),n("li",[t._v("高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳定；")]),t._v(" "),n("li",[t._v("可测试性极强；")])])]),t._v(" "),n("li",[n("strong",[t._v("条件")]),t._v(":\n"),n("ul",[n("li",[t._v("不修改参数；")]),t._v(" "),n("li",[t._v("不依赖、不修改任何函数外部的数据；")]),t._v(" "),n("li",[t._v("完全可控，参数一样，返回值一定一样: 例如函数不能包含"),n("code",[t._v("new Date()")]),t._v("或者"),n("code",[t._v("Math.rando()")]),t._v("等这种不可控因素；")]),t._v(" "),n("li",[t._v("引用透明；")])])]),t._v(" "),n("li",[t._v("我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如"),n("code",[t._v("split / join / map")]),t._v("；")])])]),t._v(" "),n("li",[n("p",[n("strong",[t._v("函数复合")]),t._v(": 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最后的目标；")]),t._v(" "),n("ul",[n("li",[n("p",[n("strong",[t._v("扁平化嵌套")]),t._v(": 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在 JS 中，函数也可以当做参数:")]),t._v(" "),n("ul",[n("li",[n("code",[t._v("f(g(k(x)))")]),t._v(": 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；")]),t._v(" "),n("li",[t._v("理想的做法: "),n("code",[t._v("xxx(f, g, k)(x)")])])])]),t._v(" "),n("li",[n("p",[n("strong",[t._v("结果传递")]),t._v(": 如果想实现上面的方式，那也就是"),n("code",[t._v("xxx")]),t._v("函数要实现的便是: 执行结果在各个函数之间的执行传递；")]),t._v(" "),n("ul",[n("li",[t._v("这时我们就能想到一个原生提供的数组方法: "),n("code",[t._v("reduce")]),t._v("，它可以按数组的顺序依次执行，传递执行结果；")]),t._v(" "),n("li",[t._v("所以我们就能够实现一个方法"),n("code",[t._v("pipe")]),t._v("，用于函数组合:")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// ...fs: 将函数组合成数组；\n// Array.prototype.reduce 进行组合；\n// p: 初始参数；\nconst pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)\n复制代码\n")])])])]),t._v(" "),n("li",[n("p",[n("strong",[t._v("使用")]),t._v(": 实现一个 驼峰命名 转 中划线命名 的功能:")])])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// 'Guo DongDong' --\x3e 'guo-dongdong'\n// 函数组合式写法\nconst toLowerCase = str => str.toLowerCase()\nconst join = curry((str, arr) => arr.join(str))\nconst split = curry((splitOn, str) => str.split(splitOn));\n\nconst toSlug = pipe(\n\ttoLowerCase,\t\n\tsplit(' '),\n\tjoin('_'),\n\tencodeURIComponent,\n);\nconsole.log(toSlug('Guo DongDong'))\n复制代码\n")])])]),n("ul",[n("li",[n("p",[n("strong",[t._v("好处")]),t._v(":")]),t._v(" "),n("ul",[n("li",[t._v("隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；")]),t._v(" "),n("li",[t._v("只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；")]),t._v(" "),n("li",[t._v("可复用性强，任何一个函数单元都可被任意复用和组合；")]),t._v(" "),n("li",[t._v("可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const log = curry((label, x) => {\n\tconsole.log(`${ label }: ${ x }`);\n\treturn x;\n});\n\nconst toSlug = pipe(\n\ttoLowerCase,\t\n\tlog('toLowerCase output'),\n\tsplit(' '),\n\tlog('split output'),\n\tjoin('_'),\n\tlog('join output'),\n\tencodeURIComponent,\n);\n复制代码\n")])])])])]),t._v(" "),n("blockquote",[n("p",[t._v("Tips:")]),t._v(" "),n("p",[t._v("一些工具纯函数可直接引用"),n("code",[t._v("lodash/fp")]),t._v("，例如"),n("code",[t._v("curry/map/split")]),t._v("等，并不需要像我们上面这样自己实现；")])])]),t._v(" "),n("li",[n("p",[n("strong",[t._v("数据不可变性")]),t._v("(immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:")]),t._v(" "),n("ul",[n("li",[n("p",[n("strong",[t._v("倡导")]),t._v(": 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新的对象，而不是直接在原对象上修改；")])]),t._v(" "),n("li",[n("p",[n("strong",[t._v("目的")]),t._v(": 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异常，能有效提高可控性与稳定性；")])]),t._v(" "),n("li",[n("p",[t._v("并不等同于"),n("code",[t._v("const")]),t._v("。使用"),n("code",[t._v("const")]),t._v("创建一个对象后，它的属性仍然可以被修改；")])]),t._v(" "),n("li",[n("p",[t._v("更类似于"),n("code",[t._v("Object.freeze")]),t._v(": 冻结对象，但"),n("code",[t._v("freeze")]),t._v("仍无法保证深层的属性不被串改；")])]),t._v(" "),n("li",[n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("immutable.js\n")])])]),n("p",[t._v(": js 中的数据不可变库，它保证了数据不可变，在 React 生态中被广泛应用，大大提升了性能与稳定性；")]),t._v(" "),n("ul",[n("li",[n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("trie\n")])])]),n("p",[t._v("数据结构:")]),t._v(" "),n("ul",[n("li",[t._v("一种数据结构，能有效地深度冻结对象，保证其不可变；")]),t._v(" "),n("li",[n("strong",[t._v("结构共享")]),t._v(": 可以共用不可变对象的内存引用地址，减少内存占用，提高数据操作性能；")])])])])])])]),t._v(" "),n("li",[n("p",[t._v("避免不同函数之间的 "),n("strong",[t._v("状态共享")]),t._v("，数据的传递使用复制或全新对象，遵守数据不可变原则；")])]),t._v(" "),n("li",[n("p",[t._v("避免从函数内部 "),n("strong",[t._v("改变外部状态")]),t._v("，例如改变了全局作用域或父级作用域上的变量值，可能会导致其它单位错误；")])]),t._v(" "),n("li",[n("p",[t._v("避免在单元函数内部执行一些 "),n("strong",[t._v("副作用")]),t._v("，应该将这些操作抽离成更独立的工具单元；")]),t._v(" "),n("ul",[n("li",[t._v("日志输出")]),t._v(" "),n("li",[t._v("读写文件")]),t._v(" "),n("li",[t._v("网络请求")]),t._v(" "),n("li",[t._v("调用外部进程")]),t._v(" "),n("li",[t._v("调用有副作用的函数")])])])])]),t._v(" "),n("li",[n("p",[n("strong",[t._v("高阶函数")]),t._v(": 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:")]),t._v(" "),n("ul",[n("li",[t._v("将逻辑行为进行 "),n("strong",[t._v("隔离抽象")]),t._v("，便于快速复用，如处理数据，兼容性等；")]),t._v(" "),n("li",[n("strong",[t._v("函数组合")]),t._v("，将一系列单元函数列表组合成功能更强大的函数；")]),t._v(" "),n("li",[n("strong",[t._v("函数增强")]),t._v("，快速地拓展函数功能，")])])]),t._v(" "),n("li",[n("p",[n("strong",[t._v("函数式编程的好处")]),t._v(":")]),t._v(" "),n("ul",[n("li",[t._v("函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；")]),t._v(" "),n("li",[t._v("不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提高稳定性与健壮性；")]),t._v(" "),n("li",[t._v("追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；")]),t._v(" "),n("li",[t._v("更易于做单元测试。")])])]),t._v(" "),n("li",[n("p",[n("strong",[t._v("总结")]),t._v(":")]),t._v(" "),n("ul",[n("li",[t._v("函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单元函数，组合调用操作数据流；")]),t._v(" "),n("li",[t._v("它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部 / 副作用；")])])])])])}),[],!1,null,null,null);e.default=s.exports}}]);