(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{444:function(t,e,a){"use strict";a.r(e);var r=a(45),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"setstate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setstate"}},[t._v("#")]),t._v(" setState")]),t._v(" "),a("h2",{attrs:{id:"setstate的异步和同步更新问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setstate的异步和同步更新问题"}},[t._v("#")]),t._v(" setState的异步和同步更新问题")]),t._v(" "),a("p",[t._v("只要你进入了 "),a("code",[t._v("react")]),t._v(" 的调度流程，那就是异步的。只要你没有进入 "),a("code",[t._v("react")]),t._v(" 的调度流程，那就是同步的。")]),t._v(" "),a("p",[t._v("在生命周期钩子函数中，或者合成事件中，是异步的")]),t._v(" "),a("p",[t._v("原因：尽可能在接收多个setState后render一次，提升性能")]),t._v(" "),a("p",[t._v("同步的场景：定时器中或者原生dom事件中")]),t._v(" "),a("h2",{attrs:{id:"setstate的数据合并"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setstate的数据合并"}},[t._v("#")]),t._v(" setState的数据合并")]),t._v(" "),a("p",[t._v("多次setState会进行合并，如果想要setState不合并，传入函数即可")]),t._v(" "),a("p",[t._v("this.setState((state, props) => ({counter: state.counter + 1})")]),t._v(" "),a("h2",{attrs:{id:"react机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react机制"}},[t._v("#")]),t._v(" React机制")]),t._v(" "),a("p",[t._v("constructor")]),t._v(" "),a("p",[t._v("render (caused by setState, newProps)")]),t._v(" "),a("p",[t._v("ComponentDidMount、ComponentDidUpdate")]),t._v(" "),a("p",[t._v("ComponentWillUnmount")]),t._v(" "),a("h3",{attrs:{id:"render"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#render"}},[t._v("#")]),t._v(" render")]),t._v(" "),a("p",[t._v("产生新的Fiber树")]),t._v(" "),a("p",[t._v("diff算法（同层级比较，不同类型的节点会局部拆卸重建，指定key保持稳定的节点）")]),t._v(" "),a("p",[t._v("​\t子节点遍历diff时，如果是中间节点变化，会对每个子节点产生一个mutation，相对低效")]),t._v(" "),a("p",[t._v("​\t给子节点指定key，优化子节点遍历。key不可变，不能使用index。（使用index的话其他节点也会发生变化）")]),t._v(" "),a("p",[t._v("差异化更新（计算差异，更新DOM树）")]),t._v(" "),a("h3",{attrs:{id:"componentdidmount"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#componentdidmount"}},[t._v("#")]),t._v(" ComponentDidMount")]),t._v(" "),a("p",[t._v("DOM操作，网络请求，订阅")]),t._v(" "),a("h3",{attrs:{id:"componentwillunmount"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#componentwillunmount"}},[t._v("#")]),t._v(" ComponentWillUnmount")]),t._v(" "),a("p",[t._v("销毁")]),t._v(" "),a("h3",{attrs:{id:"其他生命周期函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#其他生命周期函数"}},[t._v("#")]),t._v(" 其他生命周期函数")]),t._v(" "),a("ul",[a("li",[t._v("getDerivedStateFromProps：state 的值在任何时候都依赖于 props时使用；该方法返回一个对象来更新state；")]),t._v(" "),a("li",[t._v("getSnapshotBeforeUpdate：在React更新DOM之前回调的一个函数，可以获取DOM更新前的一些信息（比如说滚动位置）；")]),t._v(" "),a("li",[t._v("shouldComponentUpdate：性能优化")])]),t._v(" "),a("h2",{attrs:{id:"shouldcomponentupdate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#shouldcomponentupdate"}},[t._v("#")]),t._v(" shouldComponentUpdate")]),t._v(" "),a("p",[t._v("render的前提：state、props发生改变")]),t._v(" "),a("p",[t._v("比如state中有属性m，jsx并没有依赖m，但是m改变了会触发render，这个时候就可以用SCU")]),t._v(" "),a("p",[t._v("SCU中，改变依赖的属性，返回true；改变m，返回false")]),t._v(" "),a("p",[t._v("而且，应该所有子组件也使用SCU，否则父组件依赖的state/props改变，子组件仍然会render")]),t._v(" "),a("h3",{attrs:{id:"purecomponent和memo"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#purecomponent和memo"}},[t._v("#")]),t._v(" PureComponent和memo")]),t._v(" "),a("p",[t._v("SCU的目的是判断props和state的数据是否改变来决定返回true和false")]),t._v(" "),a("p",[t._v("PureC源码使用了shallowEqual比较state/props，memo使用compare函数比较")]),t._v(" "),a("h3",{attrs:{id:"数据不可变性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据不可变性"}},[t._v("#")]),t._v(" 数据不可变性")]),t._v(" "),a("p",[t._v("数据不可以发生改变，否则就是新数据，这样才能触发更新渲染")]),t._v(" "),a("p",[t._v("如果数据可以改变，但是pureC和memo都不能捕捉到变化，就会产生错误的行为")]),t._v(" "),a("p",[t._v("受控组件")]),t._v(" "),a("p",[t._v("React中表单组件的状态也是由react控制，称为受控组件")]),t._v(" "),a("h1",{attrs:{id:"高阶组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#高阶组件"}},[t._v("#")]),t._v(" 高阶组件")]),t._v(" "),a("p",[t._v("定义：传入旧组件，返回新组件的函数，是一种基于react特性的设计模式")]),t._v(" "),a("p",[t._v("es6中类表达式中，类名可以被省略")]),t._v(" "),a("p",[t._v("增强props、登录鉴权")]),t._v(" "),a("h1",{attrs:{id:"redux"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redux"}},[t._v("#")]),t._v(" redux")]),t._v(" "),a("p",[t._v("纯函数：相同输入产生相同输出，没有副作用，例如IO")]),t._v(" "),a("p",[t._v("redux定义：状态管理容器")]),t._v(" "),a("p",[t._v("redux要求使用action更新数据（描述更新的type和content的对象）")]),t._v(" "),a("p",[t._v("强制使用action使状态变化可追踪预测；项目中使用函数定义返回action")]),t._v(" "),a("p",[t._v("reducer：将state和action联系起来")]),t._v(" "),a("p",[t._v("reducer定义：将传入的state和action结合，生成新state的纯函数")]),t._v(" "),a("p",[t._v("三大原则：")]),t._v(" "),a("ol",[a("li",[t._v("单一数据源：state存储在一个obj tree中，obj tree存储在一个store中")]),t._v(" "),a("li",[t._v("state是只读的：唯一修改state的方式是通过action，不用担心race condition竞态问题")]),t._v(" "),a("li",[t._v("使用纯函数修改")])]),t._v(" "),a("p",[t._v("实现redux的代码：")]),t._v(" "),a("ul",[a("li",[t._v("创建store保存state：store需要使用redux.createStore(reducer)创建，传入一个reducer")]),t._v(" "),a("li",[t._v("以reducer为主体创建一个store数据库")]),t._v(" "),a("li",[t._v("通过action修改state")]),t._v(" "),a("li",[t._v("完善reducer的代码：reducer是纯函数，不能直接修改state")]),t._v(" "),a("li",[t._v("监听store变化：store.subscribe()")])]),t._v(" "),a("h2",{attrs:{id:"拆分redux"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#拆分redux"}},[t._v("#")]),t._v(" 拆分redux")]),t._v(" "),a("p",[t._v("将store、reducer、action、constants拆分成文件")]),t._v(" "),a("h2",{attrs:{id:"redux流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redux流程"}},[t._v("#")]),t._v(" redux流程")]),t._v(" "),a("p",[t._v("全局只有一个store数据库")]),t._v(" "),a("p",[t._v("组件派发action")]),t._v(" "),a("p",[t._v("reducer接收action，返回新state")]),t._v(" "),a("p",[t._v("state更新后出发通知")]),t._v(" "),a("p",[t._v("订阅者拿到最新的数据，更新到jsx，发生改变")])])}),[],!1,null,null,null);e.default=s.exports}}]);